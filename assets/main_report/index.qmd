---
title: Pathogen Surveillance Report
params:
  inputs: "_test_data/test--xan_test"
execute:
  echo: false
---

```{r knitr_settings}
knitr::opts_chunk$set(echo = FALSE, fig.width = 10, warning = FALSE)
```

 
```{r load_libraries, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(readr)
library(knitr)
library(purrr)
library(yaml)
library(phylocanvas)
library(ape)
library(magrittr)
library(pheatmap)
library(heatmaply)
library(tidyverse)
library(palmerpenguins)
library(ade4)
library(adegenet)
library(poppr)
library(ggtree)
library(igraph)
library(visNetwork)
library(phangorn)
library(ggplot2)
library(ggnewscale)
library(kableExtra)
library(plotly)
library(webshot2)
library(metacoder)
library(psminer) # Install with: devtools::install_github("grunwaldlab/psminer")
library(ggdendro)
library(rcrossref)
```

```{r parse_inputs}
group_path <- file.path(params$inputs, "inputs", "group_id.txt")
sample_data_path <- file.path(params$inputs, "inputs", "samp_data.csv")
ref_data_path <- file.path(params$inputs, "inputs", "ref_data")
assigned_refs_path <- file.path(params$inputs, "inputs", "assigned_refs.csv")
 
group <- read_lines(group_path)
sample_data <- psminer::parse_sample_meta(sample_data_path, assigned_refs_path, group)
ref_data <- psminer::parse_ref_meta(ref_data_path, assigned_refs_path, sample_data_path, group)

# Parse sendsketch data
sendsketch_paths <- list.files(file.path(params$inputs, "inputs", "sendsketch"), full.names = T)
sketch_data <- psminer::parse_sendsketch(sendsketch_paths)

# Parse variant data
variant_data_path <- file.path(params$inputs, "inputs", "variant_data")
snp_tree_paths <- list.files(variant_data_path, pattern = "\\.treefile$", full.names = TRUE)
vcf_paths <- list.files(variant_data_path, pattern = "\\.vcf\\.gz$", full.names = TRUE)
snp_align_paths <- list.files(variant_data_path, pattern = "\\.fasta$", full.names = TRUE)

# Parse ANI matrix
ani_matrix_path <- file.path(params$inputs, "inputs", "ani_matrix.csv")
ani_matrix <- psminer::parse_ani_matrix(ani_matrix_path)

# Parse core gene phylogeny
core_phylo_path <- file.path(params$inputs, "inputs", "core_phylo.treefile")

# Parse quality control data (currently not used)
multiqc_path <- file.path(params$inputs, "inputs", "multiqc")
multiqc_report_path <- file.path(multiqc_path, 'multiqc_report.html')
quast_path <- file.path(params$inputs, "inputs", "quast")
quast_ref_names <- list.files(quast_path)
quast_report_paths <- file.path(quast_path, quast_ref_names, 'report.html')

# Parse messages
messages_path <- file.path(params$inputs, "inputs", "messages.tsv")
messages <- readr::read_tsv(messages_path)

# Parse version data
version_path <- file.path(params$inputs, "inputs", "versions.yml")
version_data <- psminer::parse_software_meta(version_path)
```

# Summary

This report is produced by the **`nf-core/pathogensurveillance` pipeline**.

**Report group:** `r group`                           
**Sample count:** `r nrow(sample_data)`                 
**Last updated:** `r format(Sys.time(), '%B %d , %Y')`       
**Pipeline version:** {{< var version >}}

## Status

Perhaps a table with a list of majors steps and a icon next to each for done/queued/failed.

```{r generate-tables, eval=FALSE}
# Generate the tables using the status_tables function
tables <- status_tables(messages, interactive = TRUE)
```

::: {.panel-tabset}

## Simple Summary Table

```{r simple-table, eval=FALSE}
tables$simpleTable
```

## Detailed Samples Table

```{r detailed-samples-table, eval=FALSE}
tables$detailedSamplesTable
```

## Detailed Groups Table

```{r detailed-groups-table, eval=FALSE}
tables$detailedGroupsTable
```

:::


## {{< bi clipboard-data >}} Input data

```{r}
psminer::print_sample_metadata(sample_data)
```


# Identification

## Initial identification

The following data provides tentative classifications of the samples based on exact matches of a subset of short DNA sequences. 
These are intended to be preliminary identifications.
For more robust identifications based on whole genome sequences, see the results of the core genome phylogeny below.

::: panel-tabset
### Taxonomic classification summary

```{r}
top_hits <- psminer::best_sendsketch_hits(sketch_data)
unique_tax <- unique(top_hits$taxonomy)
is_single_taxon <- length(unique_tax) == 1
```

```{r fig.height = 8, eval = !is_single_taxon}
psminer::plot_sendsketch_taxonomy(sketch_data)
```

```{r, results='asis', eval = !is_single_taxon}
cat('
::: {.callout-tip collapse="true"}
## About this plot

This plot shows the distribution of tentative taxonomic classifications for all samples.
Only the "highest scoring" results for each sample is considered.

Hover your cursor over parts of the sunburst plot will display the number of samples in each taxon.
Clicking on a section will subset the plot to that taxon.
Clicking on the middle will undo the subset.
:::
')
```

```{r, results='asis', eval = is_single_taxon}
n_samp <- nrow(top_hits)
formatted_classification <- unique_tax %>%
    gsub(pattern = "[a-z]+:", replacement = "") %>%
    gsub(pattern = ";", replacement = " > ") 
cat(paste0(
"Initial classification of ", ifelse(n_samp == 1, "the sample", paste0(n_samp, " samples")),
" identified ", ifelse(n_samp == 1, "it", "all of them"), " as:\n\n",
"**", formatted_classification, "**"
))
```


### Per-sample classification

```{r sketchtable, fig.width=5}
psminer::sketch_idtb(sketch_data)
```

::: {.callout-tip collapse="true"}
## About this table

This table shows the "highest scoring" tentative taxonomic classification for each sample.
Included metrics can provide insights into how each sample compares with reference genomes on online databases and the likelihood these comparisions are valid.

* **Sample:** The sample ID submitted by the user.
* **WKID:** Weighted k-mer Identity, adjusted for genome size differences.
* **ANI:** An estimate of average nucleotide identity (ANI), derived from WKID and kmer length.
* **Completeness:** The percentage of the reference genome represented in the query.
* **Top Hit:** The name of the reference genome most similar to each sample based on the scoring criteria used.
:::

::: 

## Rigorous identification

This section includes phylogenetic trees of samples with references sequences downloaded from RefSeq meant to provide a reliable identification using genome-scale data.

::: panel-tabset

### Core gene phylogeny

```{r id_core_phylo, eval = length(read_lines(core_phylo_path)) > 0}
psminer::make_phylogeny(core_phylo_path, sample_data, ref_data, interactive = TRUE)
```

```{r, results='asis', eval = length(read_lines(core_phylo_path)) > 0}
cat('
::: {.callout-tip collapse="true"}
## About this plot

This a core gene phylogeny of samples with RefSeq genomes for context.
A core gene phylogeny uses the sequences of all gene shared by all of the genomes included in the tree to infer evolutionary relationships.
It is the most robust identification provided by this pipeline, but its precision is still limited by the availability of similar reference sequences. 
:::
')
```

```{r, results='asis', eval = length(read_lines(core_phylo_path)) == 0}
cat('
Could not generate core genome phylogeny.
')
```


### ANI heatmap and dendrogram

```{r ANI dendrogram, fig.height = 8, fig.width=8}
psminer::make_ani_heatmap(ani_matrix, ref_data, sample_data)
```

::: {.callout-tip collapse="true"}
## About this plot

This plot shows the results of comparing the similarity of all samples and references to eachother.
These similarity metrics are based on the presence and abundance of short exact sequence matches between samples (i.e. comparisons of k-mer sketches).
These measurments are not as reliable as the methods used to create phylogenetic trees, but may be useful if phylogenetic trees could not be inferred for these samples.
:::


:::

# Genetic diversity

*Things to address:*

1.  There are lots of NAs in metadata. I ran into issues when trying run poppr. I was trying to select a specific factor to color nodes by. As a quick workaround, changed these to 'unknown', but what is a better solution?
2.  The assembly prefix in sample names present in SNP aln output and treefile need to be discussed. In initial tool testing stage, I (Martha) have provided some quick workarounds, but this should be addressed at a larger level.
3.  Need to clarify whether to use REF in the SNP tree or else rename

```{r div_parse_inputs}
snp_trees <- ape::read.tree(snp_tree_paths)
snp_alignment <- ape::read.dna(snp_align_paths, format =  "fasta")
#Rename sample names so they don't have prefixes-may be better way
```

## Genetic diversity in sample

::: panel-tabset
### SNP tree

**Phylocanvas option**

TODO-fix how trees are rooted, so consistent with how core gene phylogeny is
TODO-may need to fix fundamental logic since only tested on two small datasets
TODO-with new data parsing functions much of the below code can be revised.

```{r snp_tree_config, include=TRUE}
#NOTE-Will tidy up code once we finalize which tree program to use and input format of files. There are many lines of code that deal with renaming samples, and these can be revised .  

#Rename tree tip labels
oldtips<-snp_trees$tip.label

#TODO generalize for any prefix
#Right now we assume REF is always in first position
#After we finalize what characters aren't allowed, 
newtips<- gsub("^[^_]+(?:_[^_]+)*_", "", oldtips)

#SNP output now has new prefix-is there a better way to deal with this, and will it be changing again? 
snp_trees$tip.label<-newtips

# Root tree
#option1
snp_trees_rootref <- root(snp_trees, "REF")
#option2
snp_trees_midpoint<-midpoint(snp_trees)

ani_matrix_format <-as.matrix(ani_matrix)
assembly_entries <- rownames(ani_matrix_format)[grepl("_assembly$", rownames(ani_matrix_format))]


name_key <- c(
  setNames(ref_data$Organism, ref_data$LastMajorReleaseAccession),
  setNames(sample_data$modified_id, sample_data$modified_id),
  setNames(assembly_entries, assembly_entries)
)

sample_ids <- snp_trees_midpoint$tip.label[snp_trees_midpoint$tip.label %in% sample_data$modified_id]

#For phycanvas version-much simpler code-but have a ggtree and ggploty version below
phycanv_snp <- phylocanvas(snp_trees_midpoint, treetype = "rectangular", alignlabels = T, showscalebar = T, width = "100%")
for (x in name_key[sample_ids]) {
  phycanv_snp <- style_node(phycanv_snp, x, labelcolor = "#24B064", labeltextsize = 30)
}
    
phycanv_snp
```

**gtree and ggplotly option**

We need to decide on best tree package. Here I experimented with ggtree and ggplotly. Requires many more lines of code than Phylocanvas. If we use ggtree alone, we lose interactivity, but may look nicer.

```{r ggtree, height=10, width=8, include=TRUE}
#One way to parse metadata file so we can color tips in a descriptive way

#add REF to metadata-only provide accession info (and maybe genus and species)
#This part can be simplified
sample_data<-sample_data
new_row <- data.frame(matrix(ncol = ncol(sample_data), nrow = 1))
colnames(new_row) <- colnames(sample_data)

new_row$sample <- "REF"

# Didn't want to mess with original data frame but this could be revised or simplified-depending on if we want to use ggtree or phylocanvas. Not an elegant solution either way. 
sample_data <- rbind(sample_data, new_row)
sample_data <- sample_data[match(snp_trees_midpoint$tip.label, sample_data$sample), ]

# We can revise, but one way to color the samples as one color, the ref as another
sample_data$text_color <- ifelse(sample_data$sample == "REF", "black", "#24B064")

# Couldn't use some of ggtree functions with plotly, so here is a workaround
snp_tree1 <- fortify(snp_trees_midpoint)

# Merge it with your sample_data for color information
snp_tree1 <- merge(snp_tree1, sample_data, by.x="label", by.y="sample")

# Using theme_minimal for a cleaner background
ggtree_snptree <- ggtree(snp_trees_midpoint, size=0.5) + 
  geom_segment(data=snp_tree1, aes(xend = x + 0.35, yend = y, x = x, y = y), xend = snp_tree1$x + 0.35, color = "lightgray") +
  geom_point(data=snp_tree1, aes(x=x, y=y, color="black"), show.legend = FALSE, size=3) +
  geom_text(data=snp_tree1, aes(x = x + 0.44 + 0.03, y = y, label = label, color=text_color), size=3, hjust=0, vjust=0.5, fontface="bold") +
  scale_color_identity() +
  theme(legend.position = "none")


# Converting to more interactive tree. Work on adjusting what is shown when cursor is on sample. 
ggtree_interactive <- ggplotly(ggtree_snptree)
ggtree_interactive

# How interactive plots can be made to work with PDF
#Perhaps adjust with if/else statement rendering as pdf vs. html, also changes interactivity of html document

#htmlwidgets::saveWidget(widget = ggtree_interactive, file = "ggtree_interactive.html")
#webshot(url = "ggtree_interactive.html", file = "ggtree_interactive.png", delay = 1, zoom = 4, vheight = 500)
```


```{asis div_no_snp_phylo, echo = is.null(snp_trees)}
There is no tree to draw, probably because there were too few samples.
More info will be added later.
```
:::

## Minimum spanning network

### *Questions to address*

TODO-fix nodes to black

```{r poppr_config}
snp_trees <- ape::read.tree(snp_tree_paths)

#Specific to output from perl script vcftosnpaln, so need to extract REF from genind (ref remains after using)
snp_aln.gi <- DNAbin2genind(snp_alignment)
snp_aln.gi <- snp_aln.gi[indNames(snp_aln.gi) != "REF"]

#Need to rename samples so no longer have prefix (may be better way)
genind_names<-indNames(snp_aln.gi)
cleaned_names <- gsub("^[^_]+(?:_[^_]+)*_", "", genind_names)
indNames(snp_aln.gi) <- cleaned_names
```

### Experimenting with less subjective ways to provide SNP cutoff-this may be a viable option but requires review

```{r mlg_config_test, eval = FALSE}

#Experimenting with less subjective approach to identifying good threshold for considering if two samples have the same genotype
# Convert to genclone

#mat <-match(indNames(snp_aln.gi), sample_data$sample)
#sample_data <- sample_data[mat, ]

#snp_genclone <- as.genclone(snp_aln.gi)
#snpdist_stats <- filter_stats(snp_genclone)

#if (length(snpdist_stats$farthest$THRESHOLDS) == 1) {
    #farthest_thresh <- snpdist_stats$farthest$THRESHOLDS
    #print(farthest_thresh)
#} else {
    #farthest_thresh <- cutoff_predictor(snpdist_stats$farthest$THRESHOLDS)
    #print(farthest_thresh)
#}


#mlg.filter(snp_genclone, distance = bitwise.dist) <- farthest_thresh

#idlist2<-mlg.id(snp_genclone)

#mlglist2<-data.frame("MLG","strain")

#colnames(mlglist2) <- c("V1","V2")

#for (name in names(idlist2)) {
#  newframe<-as.data.frame(cbind(paste0("MLG","_",name),idlist2[[name]]))
# mlglist2<-rbind(mlglist2,newframe)
#}

#colnames(mlglist2)<-c("MLG","strain")
#mlglist2<-mlglist2[mlglist2$strain != "strain",]

#make a prettier table
#mlglist2
```


### Visnetwork minimum spanning network

**Just started, but needs some work to make a comparable MSN to the one above-including legends. Hard to color nodes like in poppr as pie chart. Need to remove sample names from nodes**

**Attempting to make Visnetwork plot more useful. If you hover, you now see all samples that group together and have the same genotype**
```{r visnetwork_setup_testing, eval = nrow(sample_data) > 2}
# # Given a node ID (MLG), this function will return a string containing all sample names associated with that MLG
# # Work on simplifying code 
# get_MLG <- function(sample_name) {
#   mlg_list <- mlg.id(snp_genclone)
#   mlg <- names(mlg_list)[which(sapply(mlg_list, function(samples) sample_name %in% samples))]
#   return(mlg)
# }
# 
# # Returns a string with all samples for a given MLG
# generate_tooltip <- function(mlg) {
#   samples_with_mlg <- unlist(mlg.id(snp_genclone)[mlg])
#   return(paste(samples_with_mlg, collapse = ", "))
# }
# 
# node_data <- data.frame(
#   id = V(ms.loc$graph)$name,
#   label = sapply(V(ms.loc$graph)$name, get_MLG),  # Get MLG for each sample
#   group = V(ms.loc$graph)$color,
#   size = V(ms.loc$graph)$size
# )
# node_data$value <- node_data$size.Freq
# 
# # Apply the tooltip function to all nodes
# node_data$title <- sapply(node_data$label, generate_tooltip)  # Tooltip uses the MLG label
# 
# node_data$color <- ms.loc$colors[node_data$group]
# node_groups <- lapply(names(ms.loc$colors), function(group_name) {
#   list(color = list(background = ms.loc$colors[group_name], border = 'black'))
# })
# names(node_groups) <- names(ms.loc$colors)
# edges_data <- get.data.frame(ms.loc$graph, what="edges")
# edges_data$title <- paste("Distance:", edges_data$weight)
# edges_data$arrows <- NA
# 
# 
# visNetwork(node_data, edges_data) %>%
#   visGroups(groupname = node_groups) %>%
#   visNodes(shape = "dot", color = node_data$color, title = node_data$title) %>%
#   visInteraction(dragNodes = TRUE, dragView = TRUE, hideEdgesOnDrag = FALSE) %>%
#   visPhysics(stabilization = FALSE) %>%
#   visOptions(nodesIdSelection = TRUE)

```

# Quality control


## Input data quality

-   multiqc link

## Downloaded references

-   quast
-   table with rows for each sample with info on references chosen
    -   sample id
    -   reference id
    -   ANI between sample and reference
-   table with one row per reference (taxon id, GSA id, classification, link to ncbi)
-   sourmash output (tree?)

## Assembly and annotation

-   depth of coverage
-   quast link
-   BUSCO gene content?
-   bakta output?

## Variant calling?

-   vcfr for plots
-   iqtree model selection, number of informative sites, indels

## Core genome phylogeny

-   core gene info (how many genes, length, paralogs)
-   outlier samples causing few genes to be chosen
-   iqtree model selection, number of informative sites, indels

# References

## {{< fa flask >}} Methods

The `pathogen surveillance` pipeline used the following tools that should be referenced as appropriate:

-   A sample is first identified to genus using sendsketch and further identified to species using sourmash [@brown2016sourmash].
-   The `nextflow` data-driven computational pipeline enables deployment of complex parallel and reactive workflows [@di2017nextflow].

## {{< bi sliders >}} Input settings

Add settings used to run Nextflow and the pipeline parameters.

## {{< bi gear-wide-connected >}} Analysis software

```{r}
DT::datatable(version_data)
```

## version and packages

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```

```{r}
sessionInfo()
```

## {{< ai doi >}} Bibliography

::: {#refs}
:::

# About

{{< bi file-earmark-person >}} The **`nf-core/pathogen surveillance` pipeline** was developed by: Zach Foster, Martha Sudermann, Camilo Parada-Rojas, Fernanda Iruegas-Bocardo, Ricardo Alcalá-Briseño, [Jeff Chang](http://changlab.cgrb.oregonstate.edu/) and [Nik Grunwald](http://grunwaldlab.cgrb.oregonstate.edu/).

Other contributors include: [Alex Weisberg](https://alexandra-weisberg.com/), ...

::: callout-tip
## Feedback

To contribute, provide feedback, or report bugs please visit our [github repository](https://github.com/nf-core/pathogensurveillance).
:::

Please cite this pipeline and nf-core in publications as follows:

{{< bi file-earmark-pdf-fill >}} Foster et al. 2024. PathogenSurveillance: A nf-core pipeline for rapid analysis of pathogen genome data. In preparation.

{{< bi file-earmark-pdf-fill >}} Di Tommaso, Paolo, Maria Chatzou, Evan W Floden, Pablo Prieto Barja, Emilio Palumbo, and Cedric Notredame. 2017. Nextflow Enables Reproducible Computational Workflows. Nature Biotechnology 35 (4): 316--19. https://doi.org/10.1038/nbt.3820.

Icons for this report were sampled from [Bootstrap Icons](https://icons.getbootstrap.com), [Freepick](https://www.freepik.com), [Academicons](https://jpswalsh.github.io/academicons/), and [Font Awesome](https://fontawesome.com).
