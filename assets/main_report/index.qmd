---
title: Pathogen Surveillance Report
params:
  inputs: "/media/fosterz/external_primary/files/projects/work/current/foul_brood/work/57/99d7f9be0b4db26eb4d464998da5a2"
execute:
  echo: false
---

```{r knitr_settings}
knitr::opts_chunk$set(echo = FALSE, fig.width = 10, warning = FALSE)
options(bspm.sudo = TRUE) # Something needed when running in containers (not sure why)
```

```{r load_libraries, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(readr)
library(knitr)
library(readr)
library(purrr)
library(yaml)
library(phylocanvas)
library(ape)
library(magrittr)
library(pheatmap)
library(heatmaply)
library(tidyverse)
library(palmerpenguins)
library(ade4)
library(adegenet)
library(poppr)
library(ggtree)
library(igraph)
library(visNetwork)
library(phangorn)
library(ggplot2)
library(ggnewscale)
library(kableExtra)
library(plotly)
library(webshot2)
library(metacoder)
library(psminer)
library(ggdendro)
library(rcrossref)
```

```{r parse_inputs}
group_path <- file.path(params$inputs, "inputs", "group_id.txt")
group <- read_lines(group_path)
samp_data_path <- file.path(params$inputs, "inputs", "samp_data.csv")
samp_data <- psminer::parse_sample_meta(samp_data_path, group)

ref_data_path <- file.path(params$inputs, "inputs", "ref_data.tsv")
ref_ids_path <- file.path(params$inputs, "inputs", "ref_ids.txt")
ref_data <- psminer::parse_ref_meta(ref_data_path, ref_ids_path, samp_data)

# Parse sendsketch data (Camilo)

parse_sendsketch <- function(paths) {
    
    parse_one_file <- function(path) {
        data <- read_tsv(path, 
                         skip = 2,
                         show_col_types = FALSE, 
                         col_types = 'ccccdccccddddddddddddddcccdddddddcccc')
        id <- sub(basename(path), pattern = '\\.txt$', replacement = '')
        return(bind_cols(sample_id = rep(id, nrow(data)), data))
    }
    
    return(map_dfr(paths, parse_one_file))
}

sendsketch_paths <- list.files(file.path(params$inputs, "inputs", "sendsketch"), full.names = T)
sketch_data <- parse_sendsketch(sendsketch_paths)

# Parse variant data
variant_data_path <- file.path(params$inputs, "inputs", "variant_data")
snp_tree_paths <- list.files(variant_data_path, pattern = "\\.treefile$", full.names = TRUE)
vcf_paths <- list.files(variant_data_path, pattern = "\\.vcf\\.gz$", full.names = TRUE)
snp_align_paths <- list.files(variant_data_path, pattern = "\\.fasta$", full.names = TRUE)

# Parse ANI matrix
ani_matrix_path <- file.path(params$inputs, "inputs", "ani_matrix.csv")
ani_matrix <- read.csv(ani_matrix_path, check.names = FALSE)
ani_matrix_reformatted <- psminer::parse_ani_matrix_names(ani_matrix)

# Parse core gene phylogeny
core_phylo_path <- file.path(params$inputs, "inputs", "core_phylo.treefile")

# Parse quality control data (currently not used)
multiqc_path <- file.path(params$inputs, "inputs", "multiqc")
multiqc_report_path <- file.path(multiqc_path, 'multiqc_report.html')
quast_path <- file.path(params$inputs, "inputs", "quast")
quast_ref_names <- list.files(quast_path)
quast_report_paths <- file.path(quast_path, quast_ref_names, 'report.html')

# Parse version data (Camilo)
parse_software_meta <- function(version_path) {
    raw_version_data <- unlist(read_yaml(version_path))
    version_data <- tibble(
        module = map_chr(strsplit(names(raw_version_data), split = '.', fixed = TRUE), `[`, 1),
        program = map_chr(strsplit(names(raw_version_data), split = '.', fixed = TRUE), `[`, 2),
        version = unname(raw_version_data),
    )
    return(version_data)
}

version_path <- file.path(params$inputs, "inputs", "versions.yml")
version_data <- parse_software_meta(version_path)
```

# Summary

This report is produced by the **`nf-core/pathogensurveillance` pipeline** version {{< var version >}}.

| <!-- -->          | <!-- -->                             |
|-------------------|--------------------------------------|
| **Report group:** | `r group`                            |
| **Sample count:** | `r nrow(samp_data)`                  |
| **Last updated**  | `r format(Sys.time(), '%B %d , %Y')` |

## Status

Perhaps a table with a list of majors steps and a icon next to each for done/queued/failed.

## {{< bi clipboard-data >}} Input data

```{r}
psminer::print_sample_metadata(samp_data, interactive = knitr::is_html_output())
```


# Identification

## Initial sketch-based identification

::: panel-tabset

### Sendsketch top hits

The following table provides putative classifications of the samples based on a kmer analysis. It is important to note that these are preliminary identifications. The table incorporates several key metrics: Weighted Kmer IDentity (WKID), Average Nucleotide Identity (ANI), and Completeness. These metrics provide insights into the genomic similarity and representational completeness between the query and reference genomes.

```{r sketchtable, fig.width=5}
psminer::sketch_idtb(sketch_data)
```

::: callout-note
WKID represents the Weighted Kmer IDentity, adjusted for genome size differences. ANI, or Average Nucleotide Identity, is derived from WKID and kmer length. Completeness indicates the percentage of the reference genome represented in the query, and is derived from WKID and KID.
:::

### Taxa of top hits

This section provides an overview of the proportions of different species in the report.

Here is how we can display the whole taxonomy with plotly using the `sunburst` and `treemap` plot types:

```{r fig.height=8}
psminer::plot_sendsketch_taxonomy(sketch_data)
```

::: 

## Rigorous ID to species or subspecies

::: panel-tabset
### Core phylogeny

TODO-make psminer function, where plot is interactive if output is HTML, and not, if PDF. Ensure that dimensions are correct.

TODO-what bootstrap method is being used? If we want, we can color the branches. 

Test code chunk for building revised ggtree function-not to be run
```{r test chunk, eval = length(read_lines(core_phylo_path)) > 0}
library(ape)
library(phangorn)

core_phylogeny_path <- core_phylo_path
core_tree <- ape::read.tree(core_phylogeny_path)
sample_ids <- core_tree$tip.label[core_tree$tip.label %in% samp_data$modified_id]

group_ani <- ani_matrix_reformatted[rownames(ani_matrix_reformatted) %in% core_tree$tip.label, colnames(ani_matrix_reformatted) %in% core_tree$tip.label]

core_tree <- root(core_tree, names(which.min(colMeans(group_ani[sample_ids, ]))))

name_key <- set_names(c(ref_data$display_name_shorter, samp_data$modified_id), c(ref_data$LastMajorReleaseAccession, samp_data$modified_id))

core_tree$tip.label <- name_key[core_tree$tip.label]
core_tree$node.label[core_tree$node.label == ""] <- "100"

bootcol <- c("black", "gray")
names(bootcol) <- c("TRUE", "FALSE")

all_tip_labels <- core_tree$tip.label

# Create an empty dataframe with tip labels
combined_data <- data.frame(tip_label = all_tip_labels)



# Check for matching names in samp_data and add columns to the combined_data dataframe
matching_names <- intersect(all_tip_labels, samp_data$modified_id)

if (length(matching_names) > 0) {
  matching_data <- samp_data[samp_data$modified_id %in% matching_names, ]
  combined_data <- merge(combined_data, matching_data, by.x = "tip_label", by.y = "modified_id", all.x = TRUE)
}

# Extract unique non-NA values from color_by column

color_factors <- unique(unlist(strsplit(as.character(combined_data$color_by), ";")))
color_factors <- color_factors[!is.na(color_factors)]

combined_data[is.na(combined_data)] <- 'unknown'

if ("color_by" %in% colnames(combined_data)) {
  # Loop through each factor and create a ggtree plot
  for (fact in color_factors) {
    layout_type <- ifelse(length(core_tree$tip.label) < 15, "rectangular", "circular")

    # Create ggtree plot with conditional layout
    tree_plot <- if (layout_type == "rectangular") {
      ggtree(core_tree, size = 0.4, aes(color = as.numeric(sub(".*/", "", label)) > 95 | isTip), layout = "rectangular") %<+% combined_data +
        geom_tiplab(size = 1.0) +
        geom_tippoint(
          aes(
            color = nursery,
            fill = nursery
          ),
          size = 0.5
        ) +
        scale_color_manual("Bootstrap support", values = bootcol, labels = c("Bootstrap > 95%", "unsupported")) +
        theme(legend.position = "right") +
        theme(plot.title = element_text(hjust = 0.5)) +
        guides(color = guide_legend(override.aes = list(size = 3), order = 1)) +
        geom_treescale(fontsize = 2)
    } else {
      ggtree(core_tree, size = 0.4, aes(color = as.numeric(sub(".*/", "", label)) > 95 | isTip), layout = "circular") %<+% combined_data + 
        geom_tiplab(size = 1.0) +
        geom_tippoint(
          aes(
            color = nursery,
            fill = nursery
          ),
          size = 0.5
        ) +
        scale_color_manual("Bootstrap support", values = bootcol, labels = c("Bootstrap > 95%", "unsupported")) +
        theme(legend.position = "right") +
        theme(plot.title = element_text(hjust = 0.5)) +
        guides(color = guide_legend(override.aes = list(size = 3), order = 1)) +
        geom_treescale(fontsize = 2)
    }
    print(tree_plot)
  }
} else {
  cat("Warning: 'color_by' column not found in combined_data.")
}
```

```{r id_core_phylo, eval = length(read_lines(core_phylo_path)) > 0}
psminer::make_phylogeny(core_phylo_path, samp_data, ani_matrix_reformatted, ref_data, interactive=TRUE)
```


### ANI heatmap and dendrogram

*TODO still want option to make interactive plot if output is an HTML file, but with the renaming of columns and rows, some of the interative heatmap fxns fail to work. Still looking at how to simplify this. 

```{r ANI dendrogram, fig.height = 8, fig.width=8}
psminer::make_ani_heatmap(ani_matrix_reformatted, ref_data, samp_data, interactive = knitr::is_html_output())
```
:::

# Genetic diversity in the group(s)

*Things to address:*

1.  There are lots of NAs in metadata. I ran into issues when trying run poppr. I was trying to select a specific factor to color nodes by. As a quick workaround, changed these to 'unknown', but what is a better solution?
2.  The assembly prefix in sample names present in SNP aln output and treefile need to be discussed. In initial tool testing stage, I (Martha) have provided some quick workarounds, but this should be addressed at a larger level.
3.  Need to clarify whether to use REF in the SNP tree or else rename

```{r div_parse_inputs}
snp_trees <- ape::read.tree(snp_tree_paths)
snp_alignment <- ape::read.dna(snp_align_paths, format =  "fasta")
#Rename sample names so they don't have prefixes-may be better way
```

## Genetic diversity in sample

::: panel-tabset
### SNP tree

**Phylocanvas option**

```{r snp_tree_config, include=TRUE}
#NOTE-Will tidy up code once we finalize which tree program to use and input format of files. There are many lines of code that deal with renaming samples, and these can be revised .  

#Rename tree tip labels
oldtips<-snp_trees$tip.label

#TODO generalize for any prefix
#Right now we assume REF is always in first position
#After we finalize what characters aren't allowed, 
newtips<- gsub("^[^_]+(?:_[^_]+)*_", "", oldtips)

#SNP output now has new prefix-is there a better way to deal with this, and will it be changing again? 
snp_trees$tip.label<-newtips

# Root tree
#option1
snp_trees_rootref <- root(snp_trees, "REF")
#option2
snp_trees_midpoint<-midpoint(snp_trees)

ani_matrix_format <-as.matrix(ani_matrix)
assembly_entries <- rownames(ani_matrix_format)[grepl("_assembly$", rownames(ani_matrix_format))]


name_key <- c(
  setNames(ref_data$Organism, ref_data$LastMajorReleaseAccession),
  setNames(samp_data$modified_id, samp_data$modified_id),
  setNames(assembly_entries, assembly_entries)
)

sample_ids <- snp_trees_midpoint$tip.label[snp_trees_midpoint$tip.label %in% samp_data$modified_id]

#For phycanvas version-much simpler code-but have a ggtree and ggploty version below
phycanv_snp <- phylocanvas(snp_trees_midpoint, treetype = "rectangular", alignlabels = T, showscalebar = T, width = "100%")
for (x in name_key[sample_ids]) {
  phycanv_snp <- style_node(phycanv_snp, x, labelcolor = "#24B064", labeltextsize = 30)
}
    
phycanv_snp
```

**gtree and ggplotly option**

We need to decide on best tree package. Here I experimented with ggtree and ggplotly. Requires many more lines of code than Phylocanvas. If we use ggtree alone, we lose interactivity, but may look nicer.

```{r ggtree, height=10, width=8, include=TRUE}
#One way to parse metadata file so we can color tips in a descriptive way

#add REF to metadata-only provide accession info (and maybe genus and species)
#This part can be simplified
samp_data<-samp_data
new_row <- data.frame(matrix(ncol = ncol(samp_data), nrow = 1))
colnames(new_row) <- colnames(samp_data)

new_row$sample <- "REF"

# Didn't want to mess with original data frame but this could be revised or simplified-depending on if we want to use ggtree or phylocanvas. Not an elegant solution either way. 
samp_data <- rbind(samp_data, new_row)
samp_data <- samp_data[match(snp_trees_midpoint$tip.label, samp_data$sample), ]

# We can revise, but one way to color the samples as one color, the ref as another
samp_data$text_color <- ifelse(samp_data$sample == "REF", "black", "#24B064")

# Couldn't use some of ggtree functions with plotly, so here is a workaround
snp_tree1 <- fortify(snp_trees_midpoint)

# Merge it with your samp_data for color information
snp_tree1 <- merge(snp_tree1, samp_data, by.x="label", by.y="sample")

# Using theme_minimal for a cleaner background
ggtree_snptree <- ggtree(snp_trees_midpoint, size=0.5) + 
  geom_segment(data=snp_tree1, aes(xend = x + 0.35, yend = y, x = x, y = y), xend = snp_tree1$x + 0.35, color = "lightgray") +
  geom_point(data=snp_tree1, aes(x=x, y=y, color="black"), show.legend = FALSE, size=3) +
  geom_text(data=snp_tree1, aes(x = x + 0.44 + 0.03, y = y, label = label, color=text_color), size=3, hjust=0, vjust=0.5, fontface="bold") +
  scale_color_identity() +
  theme(legend.position = "none")


# Converting to more interactive tree. Work on adjusting what is shown when cursor is on sample. 
ggtree_interactive <- ggplotly(ggtree_snptree)
ggtree_interactive

# How interactive plots can be made to work with PDF
#Perhaps adjust with if/else statement rendering as pdf vs. html, also changes interactivity of html document

#htmlwidgets::saveWidget(widget = ggtree_interactive, file = "ggtree_interactive.html")
#webshot(url = "ggtree_interactive.html", file = "ggtree_interactive.png", delay = 1, zoom = 4, vheight = 500)
```


```{asis div_no_snp_phylo, echo = is.null(snp_trees)}
There is no tree to draw, probably because there were too few samples.
More info will be added later.
```
:::

## Minimum spanning network

### *Questions to address*

1. Martha-Currently looking at providing a few different SNP threshold that the user can then select.
2. Martha is actively experimenting with different network outputs. So far looking into Visnetwork, but another option is networkD3?*

```{r poppr_config}
#Specific to output from perl script vcftosnpaln, so need to extract REF from genind (ref remains after using )
snp_aln.gi <- DNAbin2genind(snp_alignment)
snp_aln.gi <- snp_aln.gi[indNames(snp_aln.gi) != "REF"]

#Extract just sample data for relevant sample group(s)? Way to get this from other output and just pull here? 

#Need to rename samples so no longer have prefix (may be better way)
genind_names<-indNames(snp_aln.gi)
cleaned_names <- gsub("^[^_]+(?:_[^_]+)*_", "", genind_names)
indNames(snp_aln.gi) <- cleaned_names
```

### Experimenting with less subjective ways to provide SNP cutoff-this may be a viable option but requires review

```{r mlg_config_test, eval = FALSE}

#Experimenting with less subjective approach to identifying good threshold for considering if two samples have the same genotype
# Convert to genclone

#mat <-match(indNames(snp_aln.gi), samp_data$sample)
#samp_data <- samp_data[mat, ]

#snp_genclone <- as.genclone(snp_aln.gi)
#snpdist_stats <- filter_stats(snp_genclone)

#if (length(snpdist_stats$farthest$THRESHOLDS) == 1) {
    #farthest_thresh <- snpdist_stats$farthest$THRESHOLDS
    #print(farthest_thresh)
#} else {
    #farthest_thresh <- cutoff_predictor(snpdist_stats$farthest$THRESHOLDS)
    #print(farthest_thresh)
#}


#mlg.filter(snp_genclone, distance = bitwise.dist) <- farthest_thresh

#idlist2<-mlg.id(snp_genclone)

#mlglist2<-data.frame("MLG","strain")

#colnames(mlglist2) <- c("V1","V2")

#for (name in names(idlist2)) {
#  newframe<-as.data.frame(cbind(paste0("MLG","_",name),idlist2[[name]]))
# mlglist2<-rbind(mlglist2,newframe)
#}

#colnames(mlglist2)<-c("MLG","strain")
#mlglist2<-mlglist2[mlglist2$strain != "strain",]

#make a prettier table
#mlglist2
```

Please revise as needed. I think we need a better approach to coming up with SNP threshold-as shown in code chunk above. Providing arbitrary cutoff for all datasets will sometimes not be meaningful and even incorrect.

**Martha-I cannot figure out why Poppr samples/nodes legend has a redundant node. I have not seen this with other datasets, and used pretty much the same code**

```{r poppr msn, height=10, eval = nrow(samp_data) > 2}
filter_level = 5
mat <-match(indNames(snp_aln.gi), samp_data$sample)
samp_data <- samp_data[mat, ]

# Convert to genclone
snp_genclone <- as.genclone(snp_aln.gi)

# Replace NAs with "unknown"
samp_data[] <- lapply(samp_data, function(col) {
  if (any(is.na(col))) {
    col[is.na(col)] <- "unknown"
  }
  return(col)
})

# Extract unique factors from the color_by column
factors_to_analyze <- unique(unlist(strsplit(as.character(samp_data$color_by), split = ";")))

# Loop over each factor to generate an MSN
for (current_factor in factors_to_analyze) {

    # If current factor is not a column name in samp_data, skip the iteration
    if (!current_factor %in% names(samp_data)) {
        next
    }

    # Extract the values from the corresponding column in samp_data
    temp_color_by <- as.factor(samp_data[[current_factor]])

    myColors <- rainbow(length(unique(temp_color_by)))
    names(myColors) <- levels(temp_color_by)

    # Set strata and pop with the temporary variable
    num_columns <- ncol(samp_data)

    # Extract all columns from samp_data and append the temp_color_by column
    strata(snp_genclone) <- cbind(samp_data[, c(1:num_columns)], temp_color_by)

    # Rename the appended column to "temp_color_by"
    names(strata(snp_genclone))[num_columns + 1] <- "temp_color_by"

    setPop(snp_genclone) <- ~temp_color_by
    
    #Add additional for loop for different filter levels
    
    for (filt_threshold in c(6, 11, 26, 61, 101)) {
      mlg.filter(snp_genclone, distance = bitwise.dist, percent = FALSE, threshold=filt_threshold) 
    
      ms.loc <- poppr.msn(snp_genclone,
                            distmat = bitwise.dist(snp_genclone, percent = FALSE),
                            include.ties = TRUE,
                            showplot = FALSE)
      
      the_edges <- igraph::E(ms.loc$graph)$weight
      edges <- as.list(the_edges)

      set.seed(8)
      plot_poppr_msn(
        snp_genclone,
        poppr_msn = ms.loc,
        palette = myColors,
        mlg = FALSE,
        quantiles = FALSE,
        wscale = FALSE,
        inds = "None",
        layfun = igraph::layout_with_lgl,
        edge.label = the_edges,
        edge.label.font = 2,
        edge.label.cex = 1,
        edge.label.family = "Helvetica",
        edge.label.color = "darkslateblue",
        main = paste("MSN Plot - SNP Threshold:", filter_level-1,".", "Nodes colored by", current_factor)
      )
    }
}

```

### Visnetwork minimum spanning network

**Just started, but needs some work to make a comparable MSN to the one above-including legends. Hard to color nodes like in poppr as pie chart. Need to remove sample names from nodes**

**Attempting to make Visnetwork plot more useful. If you hover, you now see all samples that group together and have the same genotype**
```{r visnetwork_setup_testing, eval = nrow(samp_data) > 2}
# # Given a node ID (MLG), this function will return a string containing all sample names associated with that MLG
# # Work on simplifying code 
# get_MLG <- function(sample_name) {
#   mlg_list <- mlg.id(snp_genclone)
#   mlg <- names(mlg_list)[which(sapply(mlg_list, function(samples) sample_name %in% samples))]
#   return(mlg)
# }
# 
# # Returns a string with all samples for a given MLG
# generate_tooltip <- function(mlg) {
#   samples_with_mlg <- unlist(mlg.id(snp_genclone)[mlg])
#   return(paste(samples_with_mlg, collapse = ", "))
# }
# 
# node_data <- data.frame(
#   id = V(ms.loc$graph)$name,
#   label = sapply(V(ms.loc$graph)$name, get_MLG),  # Get MLG for each sample
#   group = V(ms.loc$graph)$color,
#   size = V(ms.loc$graph)$size
# )
# node_data$value <- node_data$size.Freq
# 
# # Apply the tooltip function to all nodes
# node_data$title <- sapply(node_data$label, generate_tooltip)  # Tooltip uses the MLG label
# 
# node_data$color <- ms.loc$colors[node_data$group]
# node_groups <- lapply(names(ms.loc$colors), function(group_name) {
#   list(color = list(background = ms.loc$colors[group_name], border = 'black'))
# })
# names(node_groups) <- names(ms.loc$colors)
# edges_data <- get.data.frame(ms.loc$graph, what="edges")
# edges_data$title <- paste("Distance:", edges_data$weight)
# edges_data$arrows <- NA
# 
# 
# visNetwork(node_data, edges_data) %>%
#   visGroups(groupname = node_groups) %>%
#   visNodes(shape = "dot", color = node_data$color, title = node_data$title) %>%
#   visInteraction(dragNodes = TRUE, dragView = TRUE, hideEdgesOnDrag = FALSE) %>%
#   visPhysics(stabilization = FALSE) %>%
#   visOptions(nodesIdSelection = TRUE)

```
### Network D3 experiment
```{r vNe, eval = nrow(samp_data) > 2, include=FALSE}
#Network D3 testing

```
# Quality control


## Input data quality

-   multiqc link

## Downloaded references

-   quast
-   table with rows for each sample with info on references chosen
    -   sample id
    -   reference id
    -   ANI between sample and reference
-   table with one row per reference (taxon id, GSA id, classification, link to ncbi)
-   sourmash output (tree?)

## Assembly and annotation

-   depth of coverage
-   quast link
-   BUSCO gene content?
-   bakta output?

## Variant calling?

-   vcfr for plots
-   iqtree model selection, number of informative sites, indels

## Core genome phylogeny

-   core gene info (how many genes, length, paralogs)
-   outlier samples causing few genes to be chosen
-   iqtree model selection, number of informative sites, indels

# References

## {{< fa flask >}} Methods

The `pathogen surveillance` pipeline used the following tools that should be referenced as appropriate:

-   A sample is first identified to genus using sendsketch and further identified to species using sourmash [@brown2016sourmash].
-   The `nextflow` data-driven computational pipeline enables deployment of complex parallel and reactive workflows [@di2017nextflow].

## {{< bi sliders >}} Input settings

Add settings used to run Nextflow and the pipeline parameters.

## {{< bi gear-wide-connected >}} Analysis software

```{r}
DT::datatable(version_data)
```

## version and packages

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```

```{r}
sessionInfo()
```

## {{< ai doi >}} Bibliography

::: {#refs}
:::

# About

{{< bi file-earmark-person >}} The **`nf-core/pathogen surveillance` pipeline** was developed by: Zach Foster, Martha Sudermann, Camilo Parada-Rojas, Fernanda Iruegas-Bocardo, Ricardo Alcalá-Briseño, [Jeff Chang](http://changlab.cgrb.oregonstate.edu/) and [Nik Grunwald](http://grunwaldlab.cgrb.oregonstate.edu/).

Other contributors include: [Alex Weisberg](https://alexandra-weisberg.com/), ...

::: callout-tip
## Feedback

To contribute, provide feedback, or report bugs please visit our [github repository](https://github.com/nf-core/pathogensurveillance).
:::

Please cite this pipeline and nf-core in publications as follows:

{{< bi file-earmark-pdf-fill >}} Foster et al. 2024. PathogenSurveillance: A nf-core pipeline for rapid analysis of pathogen genome data. In preparation.

{{< bi file-earmark-pdf-fill >}} Di Tommaso, Paolo, Maria Chatzou, Evan W Floden, Pablo Prieto Barja, Emilio Palumbo, and Cedric Notredame. 2017. Nextflow Enables Reproducible Computational Workflows. Nature Biotechnology 35 (4): 316--19. https://doi.org/10.1038/nbt.3820.

Icons for this report were sampled from [Bootstrap Icons](https://icons.getbootstrap.com), [Freepick](https://www.freepik.com), [Academicons](https://jpswalsh.github.io/academicons/), and [Font Awesome](https://fontawesome.com).
