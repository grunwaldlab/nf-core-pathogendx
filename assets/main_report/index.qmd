---
title: Pathogen Surveillance Report
params:
  inputs: "_test_data/chaos/all_inputs"
execute:
  echo: false
bibliography: references.bib
nocite: |
  @qin2014proposed, @kurtzer2017singularity, @anaconda
# adds literature citations that aren't referenced within the report - important when citation isn't associated with a program
---

```{r knitr_settings}
knitr::opts_chunk$set(echo = FALSE, fig.width = 8, warning = FALSE, message = FALSE)
```


```{r load_libraries}
library(dplyr)
library(ggplot2)
library(readr)
library(knitr)
library(purrr)
library(yaml)
library(phylocanvas)
library(ape)
library(magrittr)
library(pheatmap)
library(heatmaply)
library(tidyverse)
library(palmerpenguins)
library(ade4)
library(adegenet)
library(poppr)
library(ggtree)
library(igraph)
library(visNetwork)
library(phangorn)
library(ggplot2)
library(ggnewscale)
library(kableExtra)
library(plotly)
library(webshot2)
library(metacoder)
library(ggdendro)
library(rcrossref)
library(psminer)
```

# Summary

```{r}
group <- report_group_parsed(params$inputs)
sample_data <- sample_meta_parsed(params$inputs)
```

This report is produced by the **`nf-core/pathogensurveillance` pipeline**.

* **Report group:** `r group`
* **Sample count:** `r nrow(sample_data)`
* **Last updated:** `r format(Sys.time(), '%B %d , %Y')`
* **Pipeline version:** {{< var version >}}

## Pipeline Status Report

This section provides an overview of the pipeline execution status, including a summary table, detailed sample-specific issues, and group-level issues for further analysis.

```{r generate-tables}
tables <- status_message_tables(params$inputs)
```

::: {.panel-tabset}

## Simple Summary

```{r simple-table}
tables$simpleTable
```

::: {.callout-tip collapse="true"}
## About this table

This table provides a high-level overview of pipeline steps where issues were detected. This tables tells you how many groups or samples have issues that require your attention.

:::

## Group-Level Issues

```{r detailed-groups-table}
tables$detailedGroupsTable
```

::: {.callout-tip collapse="true"}
## About this table

This table dives into the issues that impact entire report groups, providing a more granular view of problems not limited to individual samples but affecting the group as a whole. It helps in identifying systemic issues or errors in group-specific processes.

:::

## Sample-Level Issues

```{r detailed-samples-table}
tables$detailedSamplesTable
```

::: {.callout-tip collapse="true"}
## About this table

This table offers detailed insights into issues specific to individual samples. It is designed to help you pinpoint and address sample-specific problems, facilitating targeted troubleshooting and resolution efforts.

:::

:::


## {{< bi clipboard-data >}} Input data

```{r}
sample_meta_table(params$inputs)
```


# Identification

## Initial identification

The following data provides tentative classifications of the samples based on exact matches of a subset of short DNA sequences.
These are intended to be preliminary identifications.
For more robust identifications based on whole genome sequences, see the results of the core genome phylogeny below.

::: panel-tabset
### Taxonomic classification summary

```{r}
top_hits <- sendsketch_parsed(params$inputs, only_best = TRUE)
unique_tax <- unique(sub(top_hits$taxonomy, pattern = ';s:(.+);.+$', replacement = ';s:\\1')) # ignore below species level information
is_single_taxon <- length(unique_tax) == 1
```

```{r fig.height = 8, eval = !is_single_taxon}
psminer::sendsketch_taxonomy_plot(top_hits)
```

```{r, results='asis', eval = !is_single_taxon}
cat('
::: {.callout-tip collapse="true"}
## About this plot

This plot shows the distribution of tentative taxonomic classifications for all samples.
Only the "highest scoring" results for each sample is considered.

Hover your cursor over parts of the sunburst plot will display the number of samples in each taxon.
Clicking on a section will subset the plot to that taxon.
Clicking on the middle will undo the subset.
:::
')
```

```{r, results='asis', eval = is_single_taxon}
n_samp <- nrow(top_hits)
formatted_classification <- unique_tax %>%
    gsub(pattern = "[a-z]+:", replacement = "") %>%
    gsub(pattern = ";", replacement = " > ")
cat(paste0(
"Initial classification of ", ifelse(n_samp == 1, "the sample", paste0(n_samp, " samples")),
" identified ", ifelse(n_samp == 1, "it", "all of them"), " as:\n\n",
"**", formatted_classification, "**"
))
```


### Per-sample classification

```{r sketchtable, fig.width=5}
sendsketch_table(top_hits)
```

::: {.callout-tip collapse="true"}
## About this table

This table shows the "highest scoring" tentative taxonomic classification for each sample.
Included metrics can provide insights into how each sample compares with reference genomes on online databases and the likelihood these comparisons are valid.

* **Sample:** The sample ID submitted by the user.
* **WKID:** Weighted k-mer Identity, adjusted for genome size differences.
* **ANI:** An estimate of average nucleotide identity (ANI), derived from WKID and kmer length.
* **Completeness:** The percentage of the reference genome represented in the query.
* **Top Hit:** The name of the reference genome most similar to each sample based on the scoring criteria used.
:::

:::

## Most similar organisms

::: panel-tabset
### ANI top matches


```{r}
# Parse ANI matrix
ani_matrix_path <- file.path(params$inputs, "sourmash_ani_matrix.csv")
ani_matrix <- psminer::parse_ani_matrix(ani_matrix_path)
sample_data_path <- file.path(params$inputs, "sample_data.csv")
sample_data <- readr::read_csv(sample_data_path)
reference_data_path <- file.path(params$inputs, "reference_data.csv")
reference_data <- readr::read_csv(reference_data_path)

psminer::print_ani_table(ani_matrix * 100, sample_data, reference_data)
```

::: {.callout-tip collapse="true"}
## About this table

This table shows the Average Nucleotide Identity (ANI) between each sample and the 2 references most similar to it based on this measure.
ANI is used to measure how similar the shared portion of two genomes are.
Note that this measure only takes into account the shared portion of genomes, so differences like extra plasmids or chromosomal duplications are not taken into account.
:::


### ANI heatmap

```{r ani_heatmap, fig.height = 10}
psminer::make_ani_heatmap(ani_matrix * 100, reference_data, sample_data)
```

::: {.callout-tip collapse="true"}
## About this plot

This plot shows the results of comparing the similarity of all samples and references to each other.
These similarity metrics are based on the presence and abundance of short exact sequence matches between samples (i.e. comparisons of k-mer sketches).
These measurements are not as reliable as the methods used to create phylogenetic trees, but may be useful if phylogenetic trees could not be inferred for these samples.
:::


### POCP top matches

```{r}
pocp_matrix_path <- file.path(params$inputs, "pocp.csv")
pocp_matrix <- psminer::parse_pocp_matrix(pocp_matrix_path)
psminer::print_pocp_table(pocp_matrix, sample_data, reference_data)
```

::: {.callout-tip collapse="true"}
## About this table

This table shows the Percentage Of Conserved Proteins (POCP) between each sample and the 2 references most similar to it based on this measure.
POCP is used to measure the proportion of proteins shared between two genomes.
Which proteins are shared is determined from pairwise comparisons of all proteins between all genomes.
The POCP between two genomes is the sum of the number of shared proteins in each genome divided by the sum of the number of total proteins in each genome [@qin2014proposed].
Currently, POCP is only calculated for Prokaryotes.
:::


### POCP heatmap

```{r pocp_heatmap, fig.height = 10}
psminer::make_ani_heatmap(pocp_matrix, reference_data, sample_data)
```

::: {.callout-tip collapse="true"}
## About this plot

This plot shows the results of comparing the protein content of all samples and references to each other.
POCP is used to measure the proportion of proteins shared between two genomes.
Which proteins are shared is determined from pairwise comparisons of all proteins between all genomes.
The POCP between two genomes is the sum of the number of shared proteins in each genome divided by the sum of the number of total proteins in each genome [@qin2014proposed].
Currently, POCP is only calculated for Prokaryotes.
:::


:::

## Phylogenetic context

This section includes phylogenetic trees of samples with references sequences downloaded from [RefSeq](https://www.ncbi.nlm.nih.gov/refseq/) meant to provide a reliable identification using genome-scale data.
The accuracy of this identification depends on the presence of close reference sequences in RefSeq and the accuracy of the initial identification.


### Core gene phylogeny

```{r}
sample_data_path <- file.path(params$inputs, "sample_data.csv")
sample_data <- readr::read_csv(sample_data_path)
reference_data_path <- file.path(params$inputs, "reference_data.csv")
reference_data <- readr::read_csv(reference_data_path)
core_phylo_dir_path <- file.path(params$inputs, "core_gene_trees")
core_phylo_paths <- list.files(core_phylo_dir_path, pattern = "\\.treefile$", full.names = TRUE)
busco_path <- file.path(params$inputs, "busco_tree.nwk")
phylo_paths <- c(core_phylo_paths, busco_path)
```

```{r id_core_phylo, eval = length(phylo_paths) > 0, fig.height = 8}
core_plots <- lapply(phylo_paths, function(path) {
    psminer::make_phylogeny(path, sample_data, reference_data)
})
if (knitr::is_html_output()) {
    htmltools::tagList(setNames(core_plots, NULL))
} else {
    print(core_plots)
}
```

```{r, results='asis', eval = length(phylo_paths) > 0}
cat('
::: {.callout-tip collapse="true"}
## About this plot

This a core gene phylogeny of samples with RefSeq genomes for context.
A core gene phylogeny uses the sequences of all gene shared by all of the genomes included in the tree to infer evolutionary relationships.
It is the most robust identification provided by this pipeline, but its precision is still limited by the availability of similar reference sequences.
:::
')
```

```{r, results='asis', eval = length(phylo_paths) == 0}
cat('
Could not generate core genome phylogeny.
')
```


# Genetic diversity

```{r parse_snp_align}
sample_data_path <- file.path(params$inputs, "sample_data.csv")
sample_data <- readr::read_csv(sample_data_path)
reference_data_path <- file.path(params$inputs, "reference_data.csv")
reference_data <- readr::read_csv(reference_data_path)

group_path <- file.path(params$inputs, "group_id.txt")
group <- read_lines(group_path)
snp_align_paths <- list.files(file.path(params$inputs, "snp_alignments"), pattern = "\\.fasta$", full.names = TRUE)
snp_alignments <- parse_alignment_fastas(snp_align_paths, group)
snp_alignments <- snp_alignments[unlist(lapply(snp_alignments, function(x) !is.null(x)))]
n_variants <- unlist(lapply(snp_alignments, ncol))
snp_ref_names <- unlist(lapply(names(snp_alignments), function(id) reference_data$ref_name[! is.na(reference_data$ref_name) & reference_data$ref_id == id]))
names(snp_ref_names) <- names(snp_alignments)
```

```{r parse_snp_trees}
snp_tree_paths <- list.files(file.path(params$inputs, "snp_trees"), pattern = "\\.treefile$", full.names = TRUE)
snp_trees <- parse_snp_trees(snp_tree_paths, group)
n_samples <- unlist(lapply(snp_trees, function(tree) length(tree$tip.label) - 1))
```

## SNP trees

```{r plot_snp_trees, results='asis', eval = length(snp_trees) > 0, fig.height = 8}
for (id in names(snp_trees)) {
    cat(paste0('::: panel-tabset\n### ', id, '\n\n'))
    cat(paste0('#### **', n_samples[id], ' samples with ', n_variants[id], ' variants aligned to reference "', snp_ref_names[id], '":** \n\n'))
    a_plot <- psminer::make_phylogeny(snp_trees[[id]], sample_data, reference_data)
    if (knitr::is_html_output()) {
        cat(as.character(htmltools::as.tags(a_plot, standalone = TRUE)))
    } else {
        print(a_plot)
    }
    cat('\n:::')
}
```

```{r, results='asis', eval = length(snp_trees) > 0}
cat('
::: {.callout-tip collapse="true"}
## About this plot

This is a representation of a Single Nucleotide Polymorphism (SNP) tree, depicting the genetic relationships among samples in comparison to a reference assembly.

The tree is less robust than a core gene phylogeny and cannot offer insights on evolutionary relationships among strains, but it does offer one way to visualize the genetic diversity among samples, with genetically similar strains clustering together.

Question-does it make sense to be showing the reference within the tree?
:::
')
```

```{r div_no_snp_phylo, eval = length(snp_trees) <= 0}
cat('There is no tree to draw. See staus messages at the start of the report for details.')
```


## Minimum spanning network


```{r plot_msns, results='asis', eval = length(snp_alignments) > 0, fig.height = 8, fig.width=10}
threshold_options <- c(0.0001, 0.001, 0.01, 0.1)
total_alignments <- length(snp_alignments)

color_col <- as.character(sample_data$color_by[!is.na(sample_data$color_by)])
color_factors <- as.list(unique(unlist(strsplit(color_col, split = ';'))))
if (length(color_factors) == 0) {
    color_factors <- list(NULL)
}

cat('::: panel-tabset\n')

for (color_by in color_factors) {
    
    # Print title of tab
    if (is.null(color_by)) {
        title <- 'MSN'
    } else {
        title <- color_by
    }
    cat(paste0('### ', title, '\n\n'))
    
    # Plot for each reference
    for (reference in names(snp_alignments)) {
        cat(paste0('#### **', nrow(snp_alignments[[reference]])-1, ' samples aligned to "', reference, '":** \n\n'))
        if (!is.null(snp_alignments[[reference]]) && nrow(snp_alignments[[reference]]) > 4) {
            plot_one <- function(threshold) {
                psminer::make_MSN(snp_alignments[[reference]], sample_data, user_seed = 2, snp_diff_prop = threshold, population = color_by)
            }
            print_figures_with_selector(plot_one, selector = threshold_options, label = 'Threshold', img_class = paste0(reference, '_', title), width = 800, height = 600)
        } else {
            cat('There is no MSN to draw. See status messages at the start of the report for details.\n')
        }
    }
}

cat('\n:::\n')
```


```{r, results='asis', eval = length(snp_alignments) > 0}
cat('
::: {.callout-tip collapse="true"}

## About this plot

This figure depicts a minimium spanning network (MSN).
The nodes represent unique multiocus genotypes, and the size of nodes is proportional to the # number of samples that share the same genotype.

The edges represent the SNP differences between two given genotypes, and the darker the color of the edges, the fewer SNP differences between the two.

Note: within these MSNs, edge lengths are not proportional to SNP differences.
:::
 ')
```

```{asis div_no_snp_align, echo = length(snp_alignments) <= 0}
cat('
Could not generate minimum spanning networks. This is likely due to not having any FASTA SNP alignment inputs.
')
```


# References

## {{< fa flask >}} Methods

The `pathogen surveillance` pipeline used the following tools that should be referenced as appropriate:

-   A sample is first identified to genus using sendsketch and further identified to species using sourmash [@brown2016sourmash].
-   The `nextflow` data-driven computational pipeline enables deployment of complex parallel and reactive workflows [@di2017nextflow].

## {{< bi sliders >}} Input settings

Add settings used to run Nextflow and the pipeline parameters.

## {{< bi gear-wide-connected >}} Analysis software

```{r}
# Parse version data
version_path <- file.path(params$inputs, "versions.yml")
version_data <- psminer::parse_software_meta(version_path)

# Generate citation list based on contents of version data table, .bib file, and .csv file used to index .bib file with program names
reflist <- read.csv(file = 'references.csv')
version_data$citation <- reflist[match(version_data$program, reflist$program), 'citation']
knitr::kable(version_data)
```

## version and packages

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```

```{r}
sessionInfo()
```

## References

::: {#refs}
:::

# About

{{< bi file-earmark-person >}} The **`nf-core/pathogen surveillance` pipeline** was developed by: Zach Foster, Martha Sudermann, Camilo Parada-Rojas, Fernanda Iruegas-Bocardo, Ricardo Alcalá-Briseño, [Jeff Chang](http://changlab.cgrb.oregonstate.edu/) and [Nik Grunwald](http://grunwaldlab.cgrb.oregonstate.edu/).

Other contributors include: [Alex Weisberg](https://alexandra-weisberg.com/), ...

::: callout-tip
## Feedback

To contribute, provide feedback, or report bugs please visit our [github repository](https://github.com/nf-core/pathogensurveillance).
:::

Please cite this pipeline and nf-core in publications as follows:

{{< bi file-earmark-pdf-fill >}} Foster et al. 2024. PathogenSurveillance: A nf-core pipeline for rapid analysis of pathogen genome data. In preparation.

{{< bi file-earmark-pdf-fill >}} Di Tommaso, Paolo, Maria Chatzou, Evan W Floden, Pablo Prieto Barja, Emilio Palumbo, and Cedric Notredame. 2017. Nextflow Enables Reproducible Computational Workflows. Nature Biotechnology 35 (4): 316--19. https://doi.org/10.1038/nbt.3820.

Icons for this report were sampled from [Bootstrap Icons](https://icons.getbootstrap.com), [Freepick](https://www.freepik.com), [Academicons](https://jpswalsh.github.io/academicons/), and [Font Awesome](https://fontawesome.com).
