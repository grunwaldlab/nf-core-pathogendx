---
title: Pathogen Surveillance Report
params:
  inputs: "_test_data/1"
execute:
  echo: false
---

```{r knitr_settings}
knitr::opts_chunk$set(echo = FALSE, fig.width = 10, warning = FALSE)
```

```{r load_libraries, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(readr)
library(knitr)
library(readr)
library(purrr)
library(yaml)
library(phylocanvas)
library(ape)
library(magrittr)
library(pheatmap)
library(heatmaply)
library(tidyverse)
library(palmerpenguins)
library(ade4)
library(adegenet)
library(poppr)
library(ggtree)
library(igraph)
library(visNetwork)
library(phangorn)
library(ggplot2)
library(ggnewscale)
library(kableExtra)
library(plotly)
library(webshot2)
library(metacoder)
devtools::install_github("grunwaldlab/psminer")
library(psminer)
library(ggdendro)
```

```{r parse_inputs}
# Parse metadata
group_path <- file.path(params$inputs, "inputs", "group_id.txt")
group <- read_lines(group_path)
ref_ids_path <- file.path(params$inputs, "inputs", "ref_ids.txt")
refs <- strsplit(read_lines(ref_ids_path), split = ';', fixed = TRUE)[[1]]
samp_data_path <- file.path(params$inputs, "inputs", "samp_data.csv")
all_samp_data <- read_csv(samp_data_path, show_col_types = FALSE)
all_samp_data$modified_id <- gsub(all_samp_data$sample, pattern = "-", replacement = "_", fixed = TRUE)
group_data <- strsplit(all_samp_data$report_group, split = ";")
all_groups <- unique(unlist(group_data))
samp_data <- all_samp_data[map_lgl(group_data, function(x) group %in% x), ]
ref_data_path <- file.path(params$inputs, "inputs", "ref_data.tsv")
ref_data <- read_tsv(ref_data_path, col_types = 'dcccccccccccccccddc')

# Parse sendsketch data
sendsketch_path <- file.path(params$inputs, "inputs", "sendsketch")
sketch_data <- map_dfr(list.files(sendsketch_path), function(path) {
    data <- read_tsv(file.path(sendsketch_path, path), skip = 2,
                     show_col_types = FALSE, col_types = 'ccccdccccddddddddddddddcccdddddddcccc')
    id <- sub(path, pattern = '\\.txt$', replacement = '')
    return(bind_cols(sample_id = rep(id, nrow(data)), data))
})

# Parse variant data
variant_data_path <- file.path(params$inputs, "inputs", "variant_data")
snp_tree_paths <- list.files(variant_data_path, pattern = "\\.treefile$", full.names = TRUE)
vcf_paths <- list.files(variant_data_path, pattern = "\\.vcf\\.gz$", full.names = TRUE)
snp_align_paths <- list.files(variant_data_path, pattern = "\\.fasta$", full.names = TRUE)

# Parse ANI matrix
ani_matrix_path <- file.path(params$inputs, "inputs", "ani_matrix.csv")
ani_matrix <- read.csv(ani_matrix_path, check.names = FALSE)
rownames(ani_matrix) <- colnames(ani_matrix)

# Parse core gene phylogeny
core_phylo_path <- file.path(params$inputs, "inputs", "core_phylo.treefile")

# Parse quality control data
multiqc_path <- file.path(params$inputs, "inputs", "multiqc")
multiqc_report_path <- file.path(multiqc_path, 'multiqc_report.html')
quast_path <- file.path(params$inputs, "inputs", "quast")
quast_ref_names <- list.files(quast_path)
quast_report_paths <- file.path(quast_path, quast_ref_names, 'report.html')

# Parse version data
version_path <- file.path(params$inputs, "inputs", "versions.yml")
raw_version_data <- unlist(read_yaml(version_path))
version_data <- tibble(
    module = map_chr(strsplit(names(raw_version_data), split = '.', fixed = TRUE), `[`, 1),
    program = map_chr(strsplit(names(raw_version_data), split = '.', fixed = TRUE), `[`, 2),
    version = unname(raw_version_data)
)
```

# Summary

This report is produced by the **`nf-core/pathogensurveillance` pipeline** version {{< var version >}}.

| <!-- -->          | <!-- -->                             |
|-------------------|--------------------------------------|
| **Report group:** | `r group`                            |
| **Sample count:** | `r nrow(samp_data)`                  |
| **Last updated**  | `r format(Sys.time(), '%B %d , %Y')` |

## Status

Perhaps a table with a list of majors steps and a icon next to each for done/queued/failed.

## Sample plotly/ggtree tree from [here](https://plotly.com/ggplot2/dendrogram/)

```{r}
model <- hclust(dist(USArrests), "ave")
dhc <- as.dendrogram(model)

data <- dendro_data(dhc, type = "triangle")
p <- ggplot(segment(data)) + 
      geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + 
      coord_flip() + 
      scale_y_reverse(expand = c(0.2, 0)) +
      theme_dendro()

ggplotly(p)
```


## {{< bi clipboard-data >}} Input data

```{r}
print_sample_metadata(samp_data, interactive = knitr::is_html_output())
```


# Identification

## Initial sketch-based identification

::: panel-tabset

### Sendsketch top hits

The following table provides putative classifications of the samples based on a kmer analysis. It is important to note that these are preliminary identifications. The table incorporates several key metrics: Weighted Kmer IDentity (WKID), Average Nucleotide Identity (ANI), and Completeness. These metrics provide insights into the genomic similarity and representational completeness between the query and reference genomes.

```{r sketchtable, fig.width=5}
# Load additional packages for aesthetic formatting
#install.packages("kableExtra")

# Convert percentage fields from character to numeric
sketch_data$WKID <- as.numeric(gsub("%", "", sketch_data$WKID))
sketch_data$ANI <- as.numeric(gsub("%", "", sketch_data$ANI))
sketch_data$Complt <- as.numeric(gsub("%", "", sketch_data$Complt))

# Sort and filter data
final_table <- sketch_data %>%
  arrange(desc(sample_id), desc(WKID), desc(ANI), desc(Complt)) %>%  # Sort by sample_id, WKID, ANI, and Complt in descending order
  group_by(sample_id) %>%  # Group by sample_id
  slice_head(n = 1) %>%  # Take the first entry per group
  ungroup() %>%  # Remove grouping
  select(sample_id, WKID, ANI, Complt, taxName) %>%  # Select required columns
  rename(Sample = sample_id, 
         `WKID (%)` = WKID,
         `ANI (%)` = ANI,
         `Completeness (%)` = Complt,
         `Top Hit` = taxName)  # Rename columns

# Define a function called 'bordered_bar' that takes two arguments: 'value' and 'color'
bordered_bar <- function(value, color) {
  sprintf('<div style="border: 1px solid gray; width: 100%%; border-radius: 12px;">
            <div style="width: %s%%; background-color: %s; border-radius: 12px; text-align: center;">%s</div>
           </div>', 
          value, color, value)
}

# Apply the bordered_bar function to the relevant columns
final_table$`WKID (%)` <- sapply(final_table$`WKID (%)`, function(x) bordered_bar(x, 'lightblue'))
final_table$`ANI (%)` <- sapply(final_table$`ANI (%)`, function(x) bordered_bar(x, 'lightgreen'))
final_table$`Completeness (%)` <- sapply(final_table$`Completeness (%)`, function(x) bordered_bar(x, 'lightpink'))

# Render the table using DT for HTML output, which will make it interactive
DT::datatable(final_table, 
          options = list(
            pageLength = 10,  # Show 10 entries per page
            autoWidth = TRUE,  # Automatically adjust column width
            columnDefs = list(
              list(width = '150px', targets = c(1, 2, 3))
            ),
            searchHighlight = TRUE  # Highlight search results
          ),
          rownames = FALSE,  # Hide row numbers
          escape = FALSE  # Necessary if your table has HTML content, like the bordered bars
)



# Render the table using kable and kableExtra for HTML output
#final_table %>%
#  knitr::kable("html", escape = F, align = c('l', 'c', 'c', 'c', 'l')) %>%
#  kable_styling(bootstrap_options = "striped", full_width = F) %>%
#  column_spec(2, extra_css = "width: 150px;") %>%
#  column_spec(3, extra_css = "width: 150px;") %>%
#  column_spec(4, extra_css = "width: 150px;") %>%
#  column_spec(5, extra_css = "width: 350px;") %>%
#  column_spec(1:5, extra_css = "font-size: 14px;")

```

::: callout-note
WKID represents the Weighted Kmer IDentity, adjusted for genome size differences. ANI, or Average Nucleotide Identity, is derived from WKID and kmer length. Completeness indicates the percentage of the reference genome represented in the query, and is derived from WKID and KID.
:::

### Taxa of top hits

This section provides an overview of the proportions of different species in the report.

Here is how we can display the whole taxonomy with plotly using the `sunburst` and `treemap` plot types:

```{r fig.height=8}
top_hits <- sketch_data %>%
  arrange(desc(sample_id), desc(WKID), desc(ANI), desc(Complt)) %>%  # Sort by sample_id, WKID, ANI, and Complt in descending order
  group_by(sample_id) %>%  # Group by sample_id
  slice_head(n = 1) %>%  # Take the first entry per group
  ungroup()

x <- parse_tax_data(tax_data = top_hits,
                    class_cols = 'taxonomy',
                    class_key = c("taxon_rank", "taxon_name"),
                    class_regex = "([a-z]+)?:?([a-zA-Z0-9.-_, ]+)",
                    class_sep = ";") %>%
    filter_taxa(taxon_ranks == "s", supertaxa = TRUE)

# A more complex test data set included in metacoder
# x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
#                    class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
#                    class_regex = "^(.+)__(.+)$")


duplicated_names <- taxon_names(x)[duplicated(taxon_names(x))]
unique_taxon_names <- paste0(taxon_names(x), " (", taxon_ranks(x), ")")
names(unique_taxon_names) <- taxon_ids(x)
unique_tax_names <- ifelse(taxon_names(x) %in% duplicated_names, unique_taxon_names, taxon_names(x))
names(unique_tax_names) <- taxon_ids(x)

plot_data <- x$edge_list
plot_data$count <- n_obs_1(x)[plot_data$to]
plot_data$from <- unique_tax_names[plot_data$from]
plot_data$to <- unique_tax_names[plot_data$to]

plot_ly(
    type='sunburst',
    labels=plot_data$to,
    parents=plot_data$from,
    values=plot_data$count,
    domain=list(column=0))
```

::: 


## Rigorous ID to species or subspecies

::: panel-tabset
### Core phylogeny

```{r id_core_phylo, eval = length(read_lines(core_phylo_path)) > 0}
convert_id <- function(ids) {
    gsub(ids, pattern = "[.-]", replacement = "_")
}

core_tree <- ape::read.tree(core_phylo_path)

# Identify which tips are samples and references
sample_ids <- core_tree$tip.label[core_tree$tip.label %in% convert_id(samp_data$sample)]

# Root tree 
colnames(ani_matrix) <- convert_id(colnames(ani_matrix))
rownames(ani_matrix) <- colnames(ani_matrix)
group_ani <- ani_matrix[rownames(ani_matrix) %in% core_tree$tip.label, colnames(ani_matrix) %in% core_tree$tip.label]
core_tree <- root(core_tree, names(which.min(colMeans(group_ani[sample_ids, ]))))

# Set tip labels to taxon names for reference sequences
# TODO: need a more reliable way to get IDs
name_key <- c(
  ref_data$Organism, 
  samp_data$sample
)
names(name_key) <- c(
  convert_id(ref_data$LastMajorReleaseAccession),
  convert_id(samp_data$sample)
)
core_tree$tip.label <- name_key[core_tree$tip.label]

# Plot tree
phycanv <- phylocanvas(core_tree, treetype = "rectangular", alignlabels = T, showscalebar = T, width = "100%")
for (x in name_key[sample_ids]) {
  phycanv <- style_node(phycanv, x, labelcolor = "green", labeltextsize = 30)
}
    
phycanv
```

### ANI Neighbor-Joining Tree

```{r ANI NJ tree, include=TRUE, height=8, width=8}
#Check-what is the significance of the entry in ANI matrix with the suffix "_assembly". It isn't in "samp_data" or "ref_data". Will this be in each dataset? Right now my code assumes this-but I don't see that dataset 2 has this entry. 

convert_id <- function(ids) {
    gsub(pattern = "[.-]", replacement = "_", x = ids)
}

# Convert data.frame to matrix
ani_matrix_format <-as.matrix(ani_matrix)

# Convert ANI similarity values to distances
dist_matrix <- 1 - ani_matrix_format

colnames(dist_matrix) <- convert_id(colnames(dist_matrix))
rownames(dist_matrix) <- convert_id(rownames(dist_matrix))

nj_tree <- nj(dist_matrix)

# Handle negative branch lengths-this is one idea, but if there is a better option, please change
nj_tree$edge.length[nj_tree$edge.length < 0] <- 1e-4  

sample_ids <- nj_tree$tip.label[nj_tree$tip.label %in% convert_id(samp_data$sample)]

group_ani <- dist_matrix[rownames(dist_matrix) %in% nj_tree$tip.label, colnames(dist_matrix) %in% nj_tree$tip.label]

nj_tree <- root(nj_tree, names(which.max(colMeans(group_ani[sample_ids, ]))))

# Create a name key to relabel the tree tips
#We have 1 entry with suffix assembly-may need to organize or rename to clarify to user what this sample is

#make more generalizable, because not every dataset has this. 
assembly_entries <- rownames(ani_matrix_format)[grepl("_assembly$", rownames(ani_matrix_format))]

name_key <- c(
  setNames(ref_data$Organism, convert_id(ref_data$LastMajorReleaseAccession)),
  setNames(samp_data$sample, convert_id(samp_data$sample)),
  setNames(assembly_entries, assembly_entries)
)

# Relabel the tree tips
nj_tree$tip.label <- name_key[nj_tree$tip.label]

##Used static ggtree because I was having trouble rendering phycanvas option. It doesn't work if output is part of an output with multiple tabs. I can also try to convert to ggplotly object but you lose a lot of the ggtree functionality

# Basic tree visualization with ggtree
ggtree_ani <- ggtree(nj_tree) +
  geom_tippoint() +
  geom_tiplab(aes(color=ifelse(label %in% name_key[sample_ids], "#24B064", "black")), size=2.2) +
  scale_color_identity(guide=FALSE) +
  xlim(c(NA, max(nj_tree$edge.length) * 1.5))


ggtree_ani
```

### ANI heatmap and dendrogram

*TODO still want option to make interactive plot, but with the renaming of columns and rows, some of the interative heatmap fxns fail to work. Still looking at how to simplify this. 

```{r ANI dendrogram, fig.height = 8, fig.width=8}
psminer::make_ani_heatmap(ani_matrix, ref_data, samp_data, interactive = FALSE)
```
:::

# Genetic diversity in the group(s)

*Things to address:*

1.  There are lots of NAs in metadata. I ran into issues when trying run poppr. I was trying to select a specific factor to color nodes by. As a quick workaround, changed these to 'unknown', but what is a better solution?
2.  The assembly prefix in sample names present in SNP aln output and treefile need to be discussed. In initial tool testing stage, I (Martha) have provided some quick workarounds, but this should be addressed at a larger level.
3.  Need to clarify whether to use REF in the SNP tree or else rename

```{r div_parse_inputs}
snp_trees <- ape::read.tree(snp_tree_paths)
snp_alignment <- ape::read.dna(snp_align_paths, format =  "fasta")
#Rename sample names so they don't have prefixes-may be better way
```

## Genetic diversity in sample

::: panel-tabset
### SNP tree

**Phylocanvas option**

```{r snp_tree_config, include=TRUE}
#NOTE-Will tidy up code once we finalize which tree program to use and input format of files. There are many lines of code that deal with renaming samples, and these can be revised .  

#Rename tree tip labels
oldtips<-snp_trees$tip.label

#TODO generalize for any prefix
#Right now we assume REF is always in first position
#After we finalize what characters aren't allowed, 
newtips<- gsub("^[^_]+(?:_[^_]+)*_", "", oldtips)

#SNP output now has new prefix-is there a better way to deal with this, and will it be changing again? 
snp_trees$tip.label<-newtips

# Root tree
#option1
snp_trees_rootref <- root(snp_trees, "REF")
#option2
snp_trees_midpoint<-midpoint(snp_trees)

name_key <- c(
  setNames(ref_data$Organism, convert_id(ref_data$LastMajorReleaseAccession)),
  setNames(samp_data$sample, convert_id(samp_data$sample)),
  setNames(assembly_entries, assembly_entries)
)

#For phycanvas version-much simpler code-but have a ggtree and ggploty version below
phycanv_snp <- phylocanvas(snp_trees_midpoint, treetype = "rectangular", alignlabels = T, showscalebar = T, width = "100%")
for (x in name_key[sample_ids]) {
  phycanv_snp <- style_node(phycanv_snp, x, labelcolor = "#24B064", labeltextsize = 30)
}
    
phycanv_snp
```

**gtree and ggplotly option**

We need to decide on best tree package. Here I experimented with ggtree and ggplotly. Requires many more lines of code than Phylocanvas. If we use ggtree alone, we lose interactivity, but may look nicer.

```{r ggtree, height=10, width=8, include=TRUE}
#One way to parse metadata file so we can color tips in a descriptive way

#add REF to metadata-only provide accession info (and maybe genus and species)
#This part can be simplified
samp_data<-samp_data
new_row <- data.frame(matrix(ncol = ncol(samp_data), nrow = 1))
colnames(new_row) <- colnames(samp_data)

new_row$sample <- "REF"

# Didn't want to mess with original data frame but this could be revised or simplified-depending on if we want to use ggtree or phylocanvas. Not an elegant solution either way. 
samp_data <- rbind(samp_data, new_row)
samp_data <- samp_data[match(snp_trees_midpoint$tip.label, samp_data$sample), ]

# We can revise, but one way to color the samples as one color, the ref as another
samp_data$text_color <- ifelse(samp_data$sample == "REF", "black", "#24B064")

# Couldn't use some of ggtree functions with plotly, so here is a workaround
snp_tree1 <- fortify(snp_trees_midpoint)

# Merge it with your samp_data for color information
snp_tree1 <- merge(snp_tree1, samp_data, by.x="label", by.y="sample")

# Using theme_minimal for a cleaner background
ggtree_snptree <- ggtree(snp_trees_midpoint, size=0.5) + 
  geom_segment(data=snp_tree1, aes(xend = x + 0.35, yend = y, x = x, y = y), xend = snp_tree1$x + 0.35, color = "lightgray") +
  geom_point(data=snp_tree1, aes(x=x, y=y, color="black"), show.legend = FALSE, size=3) +
  geom_text(data=snp_tree1, aes(x = x + 0.44 + 0.03, y = y, label = label, color=text_color), size=3, hjust=0, vjust=0.5, fontface="bold") +
  scale_color_identity() +
  theme(legend.position = "none")


# Converting to more interactive tree. Work on adjusting what is shown when cursor is on sample. 
ggtree_interactive <- ggplotly(ggtree_snptree)
ggtree_interactive


# How interactive plots can be made to work with PDF
#Perhaps adjust with if/else statement rendering as pdf vs. html, also changes interactivity of html document

#htmlwidgets::saveWidget(widget = ggtree_interactive, file = "ggtree_interactive.html")
#webshot(url = "ggtree_interactive.html", file = "ggtree_interactive.png", delay = 1, zoom = 4, vheight = 500)
```


```{asis div_no_snp_phylo, echo = is.null(snp_trees)}
There is no tree to draw, probably because there were too few samples.
More info will be added later.
```
:::

## Minimum spanning network

### *Questions to address*

1. Martha-Currently looking at providing a few different SNP threshold that the user can then select.
2. Martha is actively experimenting with different network outputs. So far looking into Visnetwork, but another option is networkD3?*

```{r poppr_config}
#Specific to output from perl script vcftosnpaln, so need to extract REF from genind (ref remains after using )
snp_aln.gi <- DNAbin2genind(snp_alignment)
snp_aln.gi <- snp_aln.gi[indNames(snp_aln.gi) != "REF"]

#Extract just sample data for relevant sample group(s)? Way to get this from other output and just pull here? 

#Need to rename samples so no longer have prefix (may be better way)
genind_names<-indNames(snp_aln.gi)
cleaned_names <- gsub("^[^_]+(?:_[^_]+)*_", "", genind_names)
indNames(snp_aln.gi) <- cleaned_names
```

### Experimenting with less subjective ways to provide SNP cutoff-this may be a viable option but requires review

```{r mlg_config_test, eval = FALSE}

#Experimenting with less subjective approach to identifying good threshold for considering if two samples have the same genotype
# Convert to genclone

#mat <-match(indNames(snp_aln.gi), samp_data$sample)
#samp_data <- samp_data[mat, ]

#snp_genclone <- as.genclone(snp_aln.gi)
#snpdist_stats <- filter_stats(snp_genclone)

#if (length(snpdist_stats$farthest$THRESHOLDS) == 1) {
    #farthest_thresh <- snpdist_stats$farthest$THRESHOLDS
    #print(farthest_thresh)
#} else {
    #farthest_thresh <- cutoff_predictor(snpdist_stats$farthest$THRESHOLDS)
    #print(farthest_thresh)
#}


#mlg.filter(snp_genclone, distance = bitwise.dist) <- farthest_thresh

#idlist2<-mlg.id(snp_genclone)

#mlglist2<-data.frame("MLG","strain")

#colnames(mlglist2) <- c("V1","V2")

#for (name in names(idlist2)) {
#  newframe<-as.data.frame(cbind(paste0("MLG","_",name),idlist2[[name]]))
# mlglist2<-rbind(mlglist2,newframe)
#}

#colnames(mlglist2)<-c("MLG","strain")
#mlglist2<-mlglist2[mlglist2$strain != "strain",]

#make a prettier table
#mlglist2
```

Please revise as needed. I think we need a better approach to coming up with SNP threshold-as shown in code chunk above. Providing arbitrary cutoff for all datasets will sometimes not be meaningful and even incorrect.

**Martha-I cannot figure out why Poppr samples/nodes legend has a redundant node. I have not seen this with other datasets, and used pretty much the same code**

```{r poppr msn, height=10, eval = nrow(samp_data) > 2}
filter_level = 5
mat <-match(indNames(snp_aln.gi), samp_data$sample)
samp_data <- samp_data[mat, ]

# Convert to genclone
snp_genclone <- as.genclone(snp_aln.gi)

# Replace NAs with "unknown"
samp_data[] <- lapply(samp_data, function(col) {
  if (any(is.na(col))) {
    col[is.na(col)] <- "unknown"
  }
  return(col)
})

# Extract unique factors from the color_by column
factors_to_analyze <- unique(unlist(strsplit(as.character(samp_data$color_by), split = ";")))

# Loop over each factor to generate an MSN
for (current_factor in factors_to_analyze) {

    # If current factor is not a column name in samp_data, skip the iteration
    if (!current_factor %in% names(samp_data)) {
        next
    }

    # Extract the values from the corresponding column in samp_data
    temp_color_by <- as.factor(samp_data[[current_factor]])

    myColors <- rainbow(length(unique(temp_color_by)))
    names(myColors) <- levels(temp_color_by)

    # Set strata and pop with the temporary variable
    num_columns <- ncol(samp_data)

    # Extract all columns from samp_data and append the temp_color_by column
    strata(snp_genclone) <- cbind(samp_data[, c(1:num_columns)], temp_color_by)

    # Rename the appended column to "temp_color_by"
    names(strata(snp_genclone))[num_columns + 1] <- "temp_color_by"

    setPop(snp_genclone) <- ~temp_color_by
    
    #Add additional for loop for different filter levels
    
    for (filt_threshold in c(6, 11, 26, 61, 101)) {
      mlg.filter(snp_genclone, distance = bitwise.dist, percent = FALSE, threshold=filt_threshold) 
    
      ms.loc <- poppr.msn(snp_genclone,
                            distmat = bitwise.dist(snp_genclone, percent = FALSE),
                            include.ties = TRUE,
                            showplot = FALSE)
      
      the_edges <- igraph::E(ms.loc$graph)$weight
      edges <- as.list(the_edges)

      set.seed(8)
      plot_poppr_msn(
        snp_genclone,
        poppr_msn = ms.loc,
        palette = myColors,
        mlg = FALSE,
        quantiles = FALSE,
        wscale = FALSE,
        inds = "None",
        layfun = igraph::layout_with_lgl,
        edge.label = the_edges,
        edge.label.font = 2,
        edge.label.cex = 1,
        edge.label.family = "Helvetica",
        edge.label.color = "darkslateblue",
        main = paste("MSN Plot - SNP Threshold:", filter_level-1,".", "Nodes colored by", current_factor)
      )
    }
}

```

### Visnetwork minimum spanning network

**Just started, but needs some work to make a comparable MSN to the one above-including legends. Hard to color nodes like in poppr as pie chart. Need to remove sample names from nodes**

**Attempting to make Visnetwork plot more useful. If you hover, you now see all samples that group together and have the same genotype**
```{r visnetwork_setup_testing, eval = nrow(samp_data) > 2}
# Given a node ID (MLG), this function will return a string containing all sample names associated with that MLG
# Work on simplifying code 
get_MLG <- function(sample_name) {
  mlg_list <- mlg.id(snp_genclone)
  mlg <- names(mlg_list)[which(sapply(mlg_list, function(samples) sample_name %in% samples))]
  return(mlg)
}

# Returns a string with all samples for a given MLG
generate_tooltip <- function(mlg) {
  samples_with_mlg <- unlist(mlg.id(snp_genclone)[mlg])
  return(paste(samples_with_mlg, collapse = ", "))
}

node_data <- data.frame(
  id = V(ms.loc$graph)$name,
  label = sapply(V(ms.loc$graph)$name, get_MLG),  # Get MLG for each sample
  group = V(ms.loc$graph)$color,
  size = V(ms.loc$graph)$size
)
node_data$value <- node_data$size.Freq

# Apply the tooltip function to all nodes
node_data$title <- sapply(node_data$label, generate_tooltip)  # Tooltip uses the MLG label

node_data$color <- ms.loc$colors[node_data$group]
node_groups <- lapply(names(ms.loc$colors), function(group_name) {
  list(color = list(background = ms.loc$colors[group_name], border = 'black'))
})
names(node_groups) <- names(ms.loc$colors)
edges_data <- get.data.frame(ms.loc$graph, what="edges")
edges_data$title <- paste("Distance:", edges_data$weight)
edges_data$arrows <- NA


visNetwork(node_data, edges_data) %>%
  visGroups(groupname = node_groups) %>%
  visNodes(shape = "dot", color = node_data$color, title = node_data$title) %>%
  visInteraction(dragNodes = TRUE, dragView = TRUE, hideEdgesOnDrag = FALSE) %>%
  visPhysics(stabilization = FALSE) %>%
  visOptions(nodesIdSelection = TRUE)

```
### Network D3 experiment
```{r vNe, eval = nrow(samp_data) > 2, include=FALSE}
#Network D3 testing

```
# Quality control


## Input data quality

-   multiqc link

## Downloaded references

-   quast
-   table with rows for each sample with info on references chosen
    -   sample id
    -   reference id
    -   ANI between sample and reference
-   table with one row per reference (taxon id, GSA id, classification, link to ncbi)
-   sourmash output (tree?)

## Assembly and annotation

-   depth of coverage
-   quast link
-   BUSCO gene content?
-   bakta output?

## Variant calling?

-   vcfr for plots
-   iqtree model selection, number of informative sites, indels

## Core genome phylogeny

-   core gene info (how many genes, length, paralogs)
-   outlier samples causing few genes to be chosen
-   iqtree model selection, number of informative sites, indels

# References

## {{< fa flask >}} Methods

The `pathogen surveillance` pipeline used the following tools that should be referenced as appropriate:

-   A sample is first identified to genus using sendsketch and further identified to species using sourmash [@brown2016sourmash].
-   The `nextflow` data-driven computational pipeline enables deployment of complex parallel and reactive workflows [@di2017nextflow].

## {{< bi sliders >}} Input settings

Add settings used to run Nextflow and the pipeline parameters.

## {{< bi gear-wide-connected >}} Analysis software

```{r}
DT::datatable(version_data)
```

## version and packages

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```

```{r}
sessionInfo()
```

## {{< ai doi >}} Bibliography

::: {#refs}
:::

# About

{{< bi file-earmark-person >}} The **`nf-core/pathogen surveillance` pipeline** was developed by: Zach Foster, Martha Sudermann, Camilo Parada-Rojas, Fernanda Iruegas-Bocardo, Ricardo Alcalá-Briseño, [Jeff Chang](http://changlab.cgrb.oregonstate.edu/) and [Nik Grunwald](http://grunwaldlab.cgrb.oregonstate.edu/).

Other contributors include: [Alex Weisberg](https://alexandra-weisberg.com/), ...

::: callout-tip
## Feedback

To contribute, provide feedback, or report bugs please visit our [github repository](https://github.com/nf-core/pathogensurveillance).
:::

Please cite this pipeline and nf-core in publications as follows:

{{< bi file-earmark-pdf-fill >}} Foster et al. 2024. PathogenSurveillance: A nf-core pipeline for rapid analysis of pathogen genome data. In preparation.

{{< bi file-earmark-pdf-fill >}} Di Tommaso, Paolo, Maria Chatzou, Evan W Floden, Pablo Prieto Barja, Emilio Palumbo, and Cedric Notredame. 2017. Nextflow Enables Reproducible Computational Workflows. Nature Biotechnology 35 (4): 316--19. https://doi.org/10.1038/nbt.3820.

Icons for this report were sampled from [Bootstrap Icons](https://icons.getbootstrap.com), [Freepick](https://www.freepik.com), [Academicons](https://jpswalsh.github.io/academicons/), and [Font Awesome](https://fontawesome.com).
