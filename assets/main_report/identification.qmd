---
params:
    group: "xan_test"
    refs: "22_331_assembly"
    samp_data: "_test_data/metadata_medium.csv"
    ref_data: "_test_data/merged_assembly_stats.tsv"
    sendsketch: "_test_data/sendsketch"
    variant_data: "_test_data/variant_data"
    ani_matrix: "_test_data/xan_test_comp.csv"
    core_phylo: "_test_data/xan_test.treefile"
    multiqc: "_test_data/multiqc"
    quast: "_test_data/quast"
    versions: "_test_data/software_versions.yml"
execute:
  echo: false
---

# Identification

```{r knitr_settings, file='knitr_settings.R'}
```

```{r load_libraries, warning=FALSE, message=FALSE, file='load_libraries.R'}
# When running manually for development: source('load_libraries.R')
source('load_libraries.R')
```

```{r parse_inputs, file='parse_inputs.R'}
# When running manually for development: source('parse_inputs.R')
source('parse_inputs.R')
```

## Sendsketch

The following table provides putative classifications of the samples based on a kmer clasification analysis. It is important to note that these are preliminary identifications. The table incorporates several key metrics: Weighted Kmer IDentity (WKID), Average Nucleotide Identity (ANI), and Completeness. These metrics provide insights into the genomic similarity and representational completeness between the query and reference genomes.

```{r sketchtable,fig.width=5}
# Load additional packages for aesthetic formatting
#install.packages("kableExtra")

# Convert percentage fields from character to numeric
sketch_data$WKID <- as.numeric(gsub("%", "", sketch_data$WKID))
sketch_data$ANI <- as.numeric(gsub("%", "", sketch_data$ANI))
sketch_data$Complt <- as.numeric(gsub("%", "", sketch_data$Complt))

# Sort and filter data
final_table <- sketch_data %>%
  arrange(desc(sample_id), desc(WKID), desc(ANI), desc(Complt)) %>%  # Sort by sample_id, WKID, ANI, and Complt in descending order
  group_by(sample_id) %>%  # Group by sample_id
  slice_head(n = 1) %>%  # Take the first entry per group
  ungroup() %>%  # Remove grouping
  select(sample_id, WKID, ANI, Complt, taxName) %>%  # Select required columns
  rename(Sample = sample_id, 
         `WKID (%)` = WKID,
         `ANI (%)` = ANI,
         `Completeness (%)` = Complt,
         Taxa = taxName)  # Rename columns

# Define a function called 'bordered_bar' that takes two arguments: 'value' and 'color'
bordered_bar <- function(value, color) {
  sprintf('<div style="border: 1px solid gray; width: 100%%; border-radius: 12px;">
            <div style="width: %s%%; background-color: %s; border-radius: 12px; text-align: center;">%s</div>
           </div>', 
          value, color, value)
}

# Apply the bordered_bar function to the relevant columns
final_table$`WKID (%)` <- sapply(final_table$`WKID (%)`, function(x) bordered_bar(x, 'lightblue'))
final_table$`ANI (%)` <- sapply(final_table$`ANI (%)`, function(x) bordered_bar(x, 'lightgreen'))
final_table$`Completeness (%)` <- sapply(final_table$`Completeness (%)`, function(x) bordered_bar(x, 'lightpink'))

# Render the table using kable and kableExtra for HTML output
final_table %>%
  knitr::kable("html", escape = F, align = c('l', 'c', 'c', 'c', 'l')) %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  column_spec(2, extra_css = "width: 150px;") %>%
  column_spec(3, extra_css = "width: 150px;") %>%
  column_spec(4, extra_css = "width: 150px;") %>%
  column_spec(5, extra_css = "width: 350px;") %>%
  column_spec(1:5, extra_css = "font-size: 14px;")


```

> **Note:** WKID represents the Weighted Kmer IDentity, adjusted for genome size differences. ANI, or Average Nucleotide Identity, is derived from WKID and kmer length. Completeness indicates the percentage of the reference genome represented in the query, and is derived from WKID and KID.

## Initial ANI heatmap and dendrogram

*Martha-Not sure if this is useful, but one idea. The interactive version wasn't that useful-but maybe other options*

```{r ANI dendrogram, fig.height = 8, fig.width=8}
p1 <- pheatmap(ani_matrix, show_rownames = T, labels_row = colnames(ani_matrix))
p1
```

## Core genome phylogeny

```{r id_core_phylo, fig.height = 7}
convert_id <- function(ids) {
    gsub(ids, pattern = "[.-]", replacement = "_")
}

core_tree <- ape::read.tree(core_phylo_path)

# Identify which tips are samples and references
sample_ids <- core_tree$tip.label[core_tree$tip.label %in% convert_id(samp_data$sample)]

# Root tree 
colnames(ani_matrix) <- convert_id(colnames(ani_matrix))
rownames(ani_matrix) <- colnames(ani_matrix)
group_ani <- ani_matrix[rownames(ani_matrix) %in% core_tree$tip.label, colnames(ani_matrix) %in% core_tree$tip.label]
core_tree <- root(core_tree, names(which.min(colMeans(group_ani[sample_ids, ]))))

# Set tip labels to taxon names for reference sequences
# TODO: need a more reliable way to get IDs
name_key <- c(
  ref_data$Organism, 
  samp_data$sample
)
names(name_key) <- c(
  convert_id(ref_data$LastMajorReleaseAccession),
  convert_id(samp_data$sample)
)
core_tree$tip.label <- name_key[core_tree$tip.label]

# Plot tree
phycanv <- phylocanvas(core_tree, treetype = "rectangular", alignlabels = T, showscalebar = T, width = "100%")
for (x in name_key[sample_ids]) {
  phycanv <- style_node(phycanv, x, labelcolor = "green", labeltextsize = 30)
}
    
phycanv
```
