---
params:
    group: "xan_test"
    refs: "22_331_assembly"
    samp_data: "_test_data/metadata_medium.csv"
    ref_data: "_test_data/merged_assembly_stats.tsv"
    sendsketch: "_test_data/sendsketch"
    variant_data: "_test_data/variant_data"
    ani_matrix: "_test_data/xan_test_comp.csv"
    core_phylo: "_test_data/xan_test.treefile"
    multiqc: "_test_data/multiqc"
    quast: "_test_data/quast"
    versions: "_test_data/software_versions.yml"
execute:
  echo: false
---

# Diversity

```{r knitr_settings, file='knitr_settings.R'}
```

```{r load_libraries, warning=FALSE, message=FALSE, file='load_libraries.R'}
# When running manually for development: 
source('load_libraries.R')
```

```{r parse_inputs, file='parse_inputs.R'}
# When running manually for development:
source('parse_inputs.R')
```

*Things to address:*

1.  There are lots of NAs in metadata. I ran into issues when trying run poppr and I was trying to select a specific column to color nodes. As a quick workaround, changed these to 'unknown', but what is a better solution?
2.  The assembly prefix in sample names present in SNP aln output and treefile need to be addressed. In initial tool testing stage, I (Martha) have provided some quick workarounds, but this should be addressed at a larger level.

```{r div_parse_inputs}
#ref_meta <- read.csv(params$ref_data, sep = '\t')
#ref_meta$modified_id <- gsub(ref_meta$LastMajorReleaseAccession, pattern = ".", replacement = "_", fixed = TRUE)
samp_meta <- read.csv(params$samp_data, sep = ',')
samp_meta$modified_id <- paste0(gsub(samp_meta$sample, pattern = "-", replacement = "_", fixed = TRUE), "_T1")
#core_tree <- ape::read.tree(core_phylo_path)
#not sure this is the intended way to create snp_tree path, but just added this temporarily so everything could render
snp_tree_paths <-file.path(params$variant_data, "xan_test_22_331_assembly.treefile")
snp_align_paths <-file.path(params$variant_data, "xan_test_22_331_assembly.fasta")
snp_trees <- ape::read.tree(snp_tree_paths)
snp_alignment<-ape::read.dna(snp_align_paths, format =  "fasta")
#Rename sample names so they don't have prefixes-may be better way
```

## SNP phylogeny

```{r div_snp_tree_config, include=FALSE}
#Rename tree tip labels
oldtips<-snp_trees$tip.label
newtips <- gsub(".*_assembly_", "", oldtips)
snp_trees$tip.label<-newtips

# Root tree
#option1
snp_trees_rootref <- root(snp_trees, "REF")
#option2
snp_trees_midpoint<-midpoint(snp_trees)
```

### ggtree option (starting point)

*May not be most generalizable as one has to specify how color tips-but just another tree option. Very powerful package-but trees are not interactive*

```{r ggtree starting point, eval = ! is.null(snp_trees)}
gg <- ggtree(snp_trees_midpoint) %<+% samp_meta +
  geom_tiplab(size=2.5) +
  geom_tippoint(aes(color=factor(year),fill=factor(year)), size=4.5, stroke=0, alpha=0.75) +
  theme(legend.position="left") +
  guides(color = guide_legend(override.aes = list(size=1))) +
  geom_treescale(fontsize =2.5) 
gg
```

### Phylocanvas version

```{r div_snp_phylo, fig.height = 7, eval = ! is.null(snp_trees)}
phycanv <- phylocanvas(snp_trees_midpoint, treetype = "rectangular", alignlabels = T, showscalebar = T, width = "100%")
phycanv
```

```{asis div_no_snp_phylo, echo = is.null(snp_trees)}
There is no tree to draw, probably because there were too few samples.
More info will be added later.
```

## Minimum spanning network

### *Questions to address*

1.  Important discussion point-for running poppr, will user decide on SNP threshold? This differs depending on dataset. Can we use something like poppr *cutoff_predictor* function?

*Martha is actively experimenting. So far looking into Visnetwork, but another option is networkD3?*

```{r poppr_config}
#Specific to output from perl script vcftosnpaln, so need to extract REF from genind (ref remains after using )
snp_aln.gi <- DNAbin2genind(snp_alignment)
snp_aln.gi <- snp_aln.gi[indNames(snp_aln.gi) != "REF"]

#Extract just sample data for relevant sample group(s)? Way to get this from other output and just pull here? 

#Need to rename samples so no longer have prefix (may be better way)
genind_names<-indNames(snp_aln.gi)
cleaned_names <- gsub("22_331_assembly_", "", genind_names)
indNames(snp_aln.gi) <- cleaned_names

```

### MLG table (maybe helpful to include-not sure)

```{r mlg_config}
mat <- match(indNames(snp_aln.gi), samp_meta$sample)
samp_meta <- samp_meta[mat, ]

# Convert to genclone
snp_genclone <- as.genclone(snp_aln.gi)


# Filter genotypes at 5 nucleotides (with the default farthest neighbor algo)
mlg.filter(snp_genclone, distance = bitwise.dist, percent = FALSE) <- 6

idlist<-mlg.id(snp_genclone)

mlglist<-data.frame("MLG","strain")
colnames(mlglist) <- c("V1","V2")
for (name in names(idlist)) {
  newframe<-as.data.frame(cbind(paste0("MLG","_",name),idlist[[name]]))
  mlglist<-rbind(mlglist,newframe)
}

colnames(mlglist)<-c("MLG","strain")
mlglist<-mlglist[mlglist$strain != "strain",]
#make a prettier table
mlglist
```

### Experimenting with less subjective ways to provide SNP cutoff

Please revise as needed. I think we need a better approach to coming up with SNP threshold-as shown in code chunk above. Providing arbitrary cutoff for all datasets will sometimes not be meaningful and even incorrect.

```{r mlg_config_test}
#Experimenting with less subjective approach to identifying good threshold for considering if two samples have the same genotype

snpdist_stats<-filter_stats(snp_genclone)
print(farthest_thresh <- cutoff_predictor(snpdist_stats$farthest$THRESHOLDS))
mlg.filter(snp_genclone, distance = bitwise.dist) <- farthest_thresh
idlist2<-mlg.id(snp_genclone)

mlglist2<-data.frame("MLG","strain")
colnames(mlglist2) <- c("V1","V2")
for (name in names(idlist2)) {
  newframe<-as.data.frame(cbind(paste0("MLG","_",name),idlist2[[name]]))
  mlglist2<-rbind(mlglist2,newframe)
}

colnames(mlglist2)<-c("MLG","strain")
mlglist2<-mlglist2[mlglist2$strain != "strain",]
#make a prettier table
mlglist2
```

### Poppr MSN

```{r poppr msn, fig.height = 10}
# Create a minimum spanning network with filtered data
#Still have issues with metadata-reference seq has none-need way to include? 

#NOTE-cannot have NAs in metadata-for temp fix, changed to NA-may need better solution
samp_meta[is.na(samp_meta)] <- "unknown"

myColors <- rainbow(length(unique(samp_meta$nusery))) 
names(myColors) <- levels(samp_meta$nusery)
#myColors["Other"] <- "#808080"


setPop(snp_genclone) <- ~nusery


# Setting the strata and pop properties
strata(snp_genclone) <- samp_meta[, c(1:18)]
setPop(snp_genclone) <- ~nusery



ms.loc <- poppr.msn(snp_genclone,
                    distmat = bitwise.dist(snp_genclone, percent = FALSE),
                    include.ties = TRUE,
                    showplot = FALSE) # show nothing

#ms.loc$graph[]
#ms.loc
#str(ms.loc)
the_edges <-E(ms.loc$graph)$weight
edges<-as.list(the_edges)

# Plot a pretty plot
set.seed(8)
plot_poppr_msn(
  snp_genclone ,
  poppr_msn = ms.loc,
  palette = myColors,
  mlg = FALSE,
  quantiles = FALSE,
  wscale = FALSE,
  inds="None",
  layfun = layout_with_lgl,
  edge.label = the_edges,
  edge.label.font = 2,
  edge.label.cex = 1,
  edge.lable.family = "Helvetica",
  edge.label.color = "darkslateblue"
  
)
```

### Visnetwork minimum spanning network

*Just started, but needs some work to make a comparable MSN to the one above-including legends. Hard to color nodes like in poppr as pie chart. Need to remove sample names from nodes*

```{r visnetwork_setup}
node_data <- data.frame(
  id = V(ms.loc$graph)$name,
  label = V(ms.loc$graph)$name,
  group = V(ms.loc$graph)$color,
  size = V(ms.loc$graph)$size
)
node_data$value <- node_data$size.Freq

node_data$color <- ms.loc$colors[node_data$group]
node_groups <- lapply(names(ms.loc$colors), function(group_name) {
  list(color = list(background = ms.loc$colors[group_name], border = 'black'))
})
names(node_groups) <- names(ms.loc$colors)
edges_data <- get.data.frame(ms.loc$graph, what="edges")
edges_data$title <- paste("Distance:", edges_data$weight)
edges_data$arrows <- NA

visNetwork(node_data, edges_data) %>%
  visGroups(groupname = node_groups) %>%
  visNodes(shape = "dot", color = node_data$color) %>%
  visInteraction(dragNodes = TRUE, dragView = TRUE, hideEdgesOnDrag = FALSE) %>% 
  #visEdges(arrows = "to") %>%
  visPhysics(stabilization = FALSE) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)
```
```{r visnetwork_setup}
visNetwork(node_data, edges_data) %>%
  visGroups(groupname = node_groups) %>%
  visNodes(shape = "dot", color = node_data$color) %>%
  visInteraction(dragNodes = TRUE, dragView = TRUE, hideEdgesOnDrag = FALSE) %>% 
  #visEdges(arrows = "to") %>%
  visPhysics(stabilization = FALSE) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)
```


### Network D3 experiment

